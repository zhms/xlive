import { NIMBaseUploadFileOptions, NIMUploadFileProgressObject, NIMUploadFileResult } from '../common/CloudStorageInterface';
import { NIMCommonError, NIMStrAnyObj } from '../types';
import { NIMTeam, NIMTeamMember } from './TeamInterface';
import { NIMUserNameCard } from './UserInterface';
/**
 * 收发消息相关接口定义
 */
export interface MessageInterface {
    /**
     *
     * <h4>描述</h4>
     *
     * 向目标用户、目标群组或目标超大群发送文本消息。
     *
     * <h4>注意</h4>
     *
     * 该接口直接返回的是 sending 状态的未完成的消息体，发送完毕的消息体需要传递 options.done 获得。
     *
     * <h4>影响范围</h4>
     *
     * 调用该 API 可触发:
     * 1. 接收方的 {@link NIMGetInstanceOptions.onmsg} 回调函数
     * 2. 接收方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 3. 发送方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 4. 发送方同时在线的其它客户端 {@link NIMGetInstanceOptions.onmsg} 回调
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E5%90%84%E7%B1%BB%E6%B6%88%E6%81%AF.js" target="_blank">各类消息发送</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E6%8E%A8%E9%80%81.js" target="_blank">消息推送示例</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%B4%E6%8A%A4.js" target="_blank">会话中消息队列维护</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-%E7%BE%A4.js" target="_blank">已读回执-群</a></li>
     * </ul>
     *
     * <h4>示例</h4>
     *
     * ```js
     * nim.sendText({
     *   scene: 'p2p',
     *   to: 'account',
     *   text: 'hello',
     *   done: function(err, msg) {
     *      if (err) {
     *         console.log('发送失败', err)
     *      } else {
     *         console.log('发送消息成功，消息为: ', msg)
     *      }
     *   }
     * })
     * ```
     *
     */
    sendText(options: NIMSendTextOptions): NIMMessage;
    /**
     *
     * <h4>描述</h4>
     * 发送图片、视频、音频或其他文件。用户可以选择调用 sendFile 上传并发送文件。
     * 也可以选择先调用 previewFile 上传文件，再调用 sendFile 发送文件
     *
     * <h4>注意一</h4>
     * <ul>
     * <li>自版本 v8.9.102 和 v9.7.0+ 开始，该接口直接返回的是 sending 状态的未完成消息体，发送完毕的消息体需要传递 options.done 获得。</li>
     * </ul>
     *
     * <h4>注意二</h4>
     * <ul>
     * <li>fileInput、file、blob、filePath四个参数选择一个传入</li>
     * <li>fileInput: type='file'类型的input DOM元素的id。上传完成前请不要操作此节点上的文件</li>
     * <li>file: previewFile 回调函数的参数</li>
     * <li>blob: Blob类型JS对象</li>
     * <li>filePath: RN，小程序等特殊的 JS 运行环境专用（chooseImage 拿到的该临时路径）</li>
     * </ul>
     *
     * <h4>注意三</h4>
     * <ul>
     * <li>type: image、audio、video 或 file。默认为 file。主要区别在于消息体中 file 对象含有的信息不同</li>
     * <li>image: url, name, size, ext, w, h, type</li>
     * <li>audio: url, name, size, ext, container, dur</li>
     * <li>video: url, name, size, ext, container, dur, w, h</li>
     * <li>file:  url, name, size, ext</li>
     * </ul>
     * <h4>影响范围</h4>
     *
     * 调用该 API 可触发:
     * 1. 接收方的 {@link NIMGetInstanceOptions.onmsg} 回调函数
     * 2. 接收方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 3. 发送方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 4. 发送方同时在线的其它客户端 {@link NIMGetInstanceOptions.onmsg} 回调
     *
     * <h4>直接发送文件 & 重发文件</h4>
     *
     * ```js
     * nim.sendFile({
     *   scene: 'p2p',
     *   to: 'account',
     *   type: 'image',
     *   fileInput: 'domId',
     *   done: function(err, obj) {
     *      if (err) {
     *         console.log('发送失败', err)
     *         // 重发. 当上传文件失败时 obj 参数的 msg 附带消息体，其他情况的 obj 就是消息体。
     *         setTimeout(function () {
     *           resendMessage(obj.msg ? obj.msg : obj)
     *         }, 3000)
     *      } else {
     *         console.log('发送消息成功，消息为: ', obj)
     *      }
     *   }
     * })
     *
     * // 上传前已经能得到 idClient 做渲染
     * console.log(message.idClient)
     *
     * // 重发
     * function resendMessage(oldMessage) {
     *   nim.sendFile(Object.assign(oldMessage, {
     *     scene: 'p2p',
     *     to: 'account',
     *     type: 'image',
     *     fileInput: 'domId',
     *     resend: true, // 注意这个 resend 标记为 true，才能固定使用 oldMessage 里的 idClient
     *     done: function(err, obj) {
     *      if (err) {
     *         console.log('发送失败', err)
     *      } else {
     *         console.log('发送消息成功，消息为: ', obj)
     *      }
     *     }
     *   }))
     * }
     * ```
     *
     * <h4>先previewFile，再发送文件</h4>
     *
     * ```js
     * nim.previewFile({
     *    type: 'image',
     *    fileInput: fileInput,
     *    uploadprogress: function(obj) {
     *        console.log('文件总大小: ' + obj.total + 'bytes');
     *        console.log('已经上传的大小: ' + obj.loaded + 'bytes');
     *        console.log('上传进度: ' + obj.percentage);
     *        console.log('上传进度文本: ' + obj.percentageText);
     *    },
     *    done: function(error, file) {
     *        console.log('上传image' + (!error?'成功':'失败'));
     *        // show file to the user
     *        if (!error) {
     *            var msg = nim.sendFile({
     *                scene: 'p2p',
     *                to: 'account',
     *                file: file,
     *                done: sendMsgDone
     *            });
     *            console.log('正在发送p2p image消息, id=' + msg.idClient);
     *            pushMsg(msg);
     *        }
     *    }
     * })
     * ```
     *
     * <h4>关联链接</h4>
     * <ul>
     * <li>{@link CloudStorageInterface.previewFile}</li>
     * <li><a href="https://doc.yunxin.163.com/messaging/docs/zQ5MjI3ODY?platform=web#%E6%94%B6%E5%8F%91%E6%96%87%E4%BB%B6%E6%B6%88%E6%81%AF">收发文件消息</a></li>
     * </ul>
     */
    sendFile(options: NIMSendFileOptions): NIMMessage;
    /**
     *
     * <h4>描述</h4>
     *
     * 当 SDK 提供的能力无法满足您的业务需求时，调用该 API 进行个性化定制并在单聊和群聊场景（包括群组和超大群）中发送，例如石头剪刀布和投骰子功能。
     *
     * <h4>注意</h4>
     *
     * 该接口直接返回的是 sending 状态的未完成消息体，发送完毕的消息体需要传递 options.done 获得。
     *
     * <h4>影响范围</h4>
     *
     * 调用该 API 可触发:
     * 1. 接收方的 {@link NIMGetInstanceOptions.onmsg} 回调函数
     * 2. 接收方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 3. 发送方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 4. 发送方同时在线的其它客户端 {@link NIMGetInstanceOptions.onmsg} 回调
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E5%86%85%E5%AE%B9%E5%AE%A1%E6%A0%B8.js" target="_blank">内容审核</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E8%A1%A8%E6%83%85.js" target="_blank">发送表情</a></li>
     * </ul>
     *
     * <h4>示例</h4>
     *
     * ```js
     * nim.sendCustomMsg({
     *   scene: 'p2p',
     *   to: 'account',
     *   //接收方通过onMsg接收消息
     *   //然后如果msg.type === 'custom'，接收方通过读取msg.content，然后调用业务代码
     *   content: JSON.stringify({type: 1}),
     *   done: function(err, msg) {
     *      if (err) {
     *         console.log('发送失败', err)
     *      } else {
     *         console.log('发送消息成功，消息为: ', msg)
     *      }
     *   }
     * })
     * ```
     */
    sendCustomMsg(options: NIMSendCustomMsgOptions): NIMMessage;
    /**
     *
     * <h4>描述</h4>
     *
     * 向目标用户、目标群组或目标超大群发送地理位置消息。
     *
     * <h4>注意</h4>
     *
     * 该接口直接返回的是 sending 状态的未完成消息体，发送完毕的消息体需要传递 options.done 获得。
     *
     * <h4>影响范围</h4>
     *
     * 调用该 API 可触发:
     * 1. 接收方的 {@link NIMGetInstanceOptions.onmsg} 回调函数
     * 2. 接收方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 3. 发送方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 4. 发送方同时在线的其它客户端 {@link NIMGetInstanceOptions.onmsg} 回调
     *
     * <h4>示例</h4>
     *
     * ```js
     * nim.sendGeo({
     *   scene: 'p2p',
     *   to: 'account',
     *   //接收方通过onMsg接收消息
     *   //然后如果msg.type === 'geo'，接收方通过读取msg.geo，然后调用业务代码
     *   geo: {
     *      lng: 116.3833,
     *      lat: 39.9167,
     *      title: 'Beijing'
     *   },
     *   done: function(err, msg) {
     *      if (err) {
     *         console.log('发送失败', err)
     *      } else {
     *         console.log('发送消息成功，消息为: ', msg)
     *      }
     *   }
     * })
     * ```
     *
     */
    sendGeo(options: NIMSendGEOOptions): NIMMessage;
    /**
     *
     * <h4>描述</h4>
     *
     * 向目标用户、目标群组或目标超大群发送提示消息。提示消息主要用于会话内的通知提醒，典型业务场景包括进入群组时出现的欢迎消息和会话过程中命中敏感词后的提示等。
     *
     * <h4>注意</h4>
     *
     * 该接口直接返回的是 sending 状态的未完成消息体，发送完毕的消息体需要传递 options.done 获得。
     *
     * <h4>影响范围</h4>
     *
     * 调用该 API 可触发:
     * 1. 接收方的 {@link NIMGetInstanceOptions.onmsg} 回调函数
     * 2. 接收方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 3. 发送方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 4. 发送方同时在线的其它客户端 {@link NIMGetInstanceOptions.onmsg} 回调
     *
     * <h4>示例</h4>
     *
     * ```js
     * nim.sendTipMsg({
     *   scene: 'p2p',
     *   to: 'account',
     *   //接收方通过onMsg接收消息
     *   //然后如果msg.type === 'tip'，接收方通过读取msg.tip，然后调用业务代码
     *   tip: 'tip content',
     *   done: function(err, msg) {
     *      if (err) {
     *         console.log('发送失败', err)
     *      } else {
     *         console.log('发送消息成功，消息为: ', msg)
     *      }
     *   }
     * })
     * ```
     */
    sendTipMsg(options: NIMSendTipMsgOptions): NIMMessage;
    /**
     * @deprecated 发送机器人消息。此接口废弃
     */
    sendRobotMsg(options: NIMBaseSendMsgOptions): NIMMessage;
    /**
     * @deprecated 此接口废弃，使用发送接口替代。<br>
     *
     * <h4>描述</h4>
     *
     * 发送消息失败后，可以通过resendMsg重发消息.
     *
     * 注: 此接口废弃，若要实现重发效果，请使用 sendText、sendFile 等发送接口并且传入参数 { resend: true } 代表重发。查看 {@link MessageInterface.sendFile | sendFile} 里的代码示例
     *
     * <h4>影响范围</h4>
     *
     * 调用该 API 触发:
     * 1. 接收方的 {@link NIMGetInstanceOptions.onmsg} 回调函数
     * 2. 接收方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 3. 发送方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 4. 发送方同时在线的其它客户端 {@link NIMGetInstanceOptions.onmsg} 回调
     */
    resendMsg(options: NIMResendMsgOptions): NIMMessage;
    /**
     * <h4>描述</h4>
     *
     * 将消息转发至其它会话中
     *
     * 注: 该接口直接返回的是 sending 状态的未完成 message，发送完毕的消息体需要传递 options.done 获得。
     *
     * <h4>影响范围</h4>
     *
     * 调用该 API 发送触发:
     * 1. 接收方的 {@link NIMGetInstanceOptions.onmsg} 回调函数
     * 2. 接收方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 3. 发送方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调
     * 4. 发送方同时在线的其它客户端 {@link NIMGetInstanceOptions.onmsg} 回调
     */
    forwardMsg(options: {
        /**
         * 待转发的消息。
         */
        msg: NIMMessage;
        /**
         * 消息场景
         */
        scene: NIMMsgScene;
        /**
         * 新的接收方，对方的 IM 账号（accid）或者对方所在的群的 ID
         */
        to: string;
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null, data: NIMMessage) => void;
    }): NIMMessage;
    /**
     *
     * <h4>描述</h4>
     *
     * 发送单聊消息的已读回执。
     *
     * <h4>使用场景</h4>
     *
     * 单聊场景下，用户B 收到 用户A 发送的消息后，将消息标注为已读。
     *
     * <h4>注意</h4>
     *
     * 已读回执分有两种接收方式：
     * 1. 初始化登录时，在同步阶段下发会话的已读回执时间, 必须设置{@link NIMGetInstanceOptions.syncMsgReceipts} = true，才能够接收
     * 2. 在线时，如果其它用户发送已读回执，通过{@link NIMGetInstanceOptions.onupdatesessions} 监听会话的最新已读回执时间
     *
     * <h4>影响范围</h4>
     *
     * 调用该 API 后，可触发已读回执接收方的 {@link NIMGetInstanceOptions.onupdatesessions} 回调。
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-%E5%8D%95%E8%81%8A.js" target="_blank">已读回执-单聊</a></li>
     * </ul>
     *
     */
    sendMsgReceipt(options: {
        /**
         * 待发回执的消息。
         */
        msg: NIMMessage;
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null) => void;
    }): void;
    /**
     *
     * <h4>描述</h4>
     *
     * 群消息接收发送消息已读回执。发送方如果在线且已在初始化时注册 onTeamMsgReceipt ，会收到群消息已读的通知
     *
     * <h4>注意</h4>
     *
     * 注意，发送者必须设置needMsgReceipt = true，接收者才能够发送群消息已读回执
     *
     * 群消息已读回执分有两种接收方式：
     * 1. 初始化登录时，在同步阶段下发会话的已读回执时间, 必须设置{@link NIMGetInstanceOptions.syncMsgReceipts} = true，才能够接收
     * 2. 在线时，如果其它用户发送已读回执，通过{@link NIMGetInstanceOptions.onTeamMsgReceipt} 监听会话的最新已读回执时间
     *
     * <h4>影响范围</h4>
     *
     * 调用该 API 发送成功时可触发: 回执接收方的 {@link NIMGetInstanceOptions.onTeamMsgReceipt | onTeamMsgReceipt} 回调。
     *
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-%E7%BE%A4.js" target="_blank">已读回执-群</a></li>
     * </ul>
     *
     * <h4>示例</h4>
     *
     * ```js
     * //消息发送方
     * nim.sendText({
     *   scene: 'team',
     *   to: 'teamId',
     *   text: "Hello",
     *   //注意，该字段必须设置为true
     *   needMsgReceipt: true
     * })
     *
     * //消息接收方
     * nim.sendTeamMsgReceipt({
     *   teamMsgReceipts: [{
     *     teamId: 'teamId',
     *     idClient: 'xxxx',
     *     idServer: 'yyyy'
     *   }]
     * })
     * ```
     */
    sendTeamMsgReceipt(options: {
        /**
         * 待发回执的群消息列表。
         */
        teamMsgReceipts: {
            /**
             * 群 id
             */
            teamId: string;
            /**
             * 消息的 {@link NIMMessage.idServer | idServer}
             */
            idServer: string;
            /**
             * 消息的 {@link NIMMessage.idClient | idClient}
             *
             * 注: 若开启本地数据库支持且传入该参数，则 SDK 会将查询到的结果存到本地数据库中
             */
            idClient?: string;
        }[];
        /**
         * done 回调。该回调需开发者自定义。
         */
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null) => void;
    }): void;
    /**
     * 查询群组消息的已读、未读数量。
     *
     * - 对应于群组消息发送时配置了needMsgReceipt字段的群组消息，接收方可以对消息发送已读回执
     * - done 回调的第二个参数是发送的参数，用于校验，第三个参数才是实际的结果
     * - 在支持db，且存在idClient时：
     *   - 查询完成后，db中对应的msg会拥有 read和unread属性，分别对应消息的已读未读人数
     *   - unread为 0 后，消息的已读、未读数量便不会再变化了，因此建议在调用该接口前，过滤掉unread已为0的消息，减少不必要的性能消耗
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-%E7%BE%A4.js" target="_blank">已读回执-群</a></li>
     * </ul>
     */
    getTeamMsgReads(options: {
        /**
         * 待查询的群消息
         */
        teamMsgReceipts: {
            /**
             * 群 id
             */
            teamId: string;
            /**
             * 消息的 {@link NIMMessage.idServer | idServer}
             */
            idServer: string;
            /**
             * 消息的 {@link NIMMessage.idClient | idClient}
             *
             * 注: 若开启本地数据库支持且传入该参数，则 SDK 会将查询到的结果存到本地数据库中
             */
            idClient?: string;
        }[];
        /**
         * 注意这个回调的真实返回数据在第三个参数
         */
        done?: (err: NIMCommonError | null | NIMStrAnyObj, param: {
            teamMsgReceipts: {
                /**
                 * 群 id
                 */
                teamId: string;
                /**
                 * 消息的 {@link NIMMessage.idServer | idServer}
                 */
                idServer: string;
                /**
                 * 消息的 {@link NIMMessage.idClient | idClient}
                 *
                 * 注: 若开启本地数据库支持且传入该参数，则 SDK 会将查询到的结果存到本地数据库中
                 */
                idClient?: string;
            }[];
        }, data: {
            teamMsgReceipts: NIMTeamMsgReceipts[];
        }) => void;
    }): void;
    /**
     * 查询群组已读、未读账号列表
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-%E7%BE%A4.js" target="_blank">已读回执-群</a></li>
     * </ul>
     */
    getTeamMsgReadAccounts(options: {
        /**
         * 待查询的群消息
         */
        teamMsgReceipt: {
            /**
             * 群 id
             */
            teamId: string;
            /**
             * 消息的 {@link NIMMessage.idServer | idServer}
             */
            idServer: string;
            /**
             * 消息的 {@link NIMMessage.idClient | idClient}
             *
             * 注: 若开启本地数据库支持且传入该参数，则 SDK 会将查询到的结果存到本地数据库中
             */
            idClient?: string;
        };
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null, arg: NIMGetTeamMsgReadAccountsResult) => void;
    }): void;
    /**
     * @deprecated 该方法已废弃，请使用 {@link MessageInterface.recallMsg | recallMsg}
     */
    deleteMsg(options: {
        /**
         * 待撤回的消息
         */
        msg: NIMMessage;
        /**
         * 自定义推送文案
         */
        apnsText?: string;
        /**
         * 第三方自定义的推送属性，限制使用 JSON 格式化的字符串。更多说明及相关示例请参见<a href="https://doc.yunxin.163.com/messaging/docs/DQyNjc5NjE?platform=server" target="_blank">推送payload配置</a>
         */
        pushPayload?: string;
        /**
         * 附言
         */
        ps?: string;
        /**
         * 附加信息，推荐使用 JSON 格式化字符串
         */
        attach?: string;
        /**
         * 指定当前消息需要抄送到或者回调到的环境的名称。开通消息抄送或第三方回调后，该环境名称可在云信控制台中配置（如下图），最大 32 个字符。
         *
         *
         * @note
         *
         * <br>
         *
         * <ul><li>开通与配置消息抄送功能的详情，请参见<a href="https://doc.yunxin.163.com/messaging/docs/jY5MDk1NTQ?platform=server" target="_blank">开通消息抄送</a>。</li><li>第三方回调相关详情，请参见<a href="https://doc.yunxin.163.com/messaging/docs/jI3ODc2ODE?platform=server" target="_blank">第三方回调概述</a>。</li></ul>
         *
         * <img style="max-width:100%;" src="https://yx-web-nosdn.netease.im/common/67dfaa431a321abfb77e5f238da47b62/自定义抄送环境.png" />
         */
        env?: string;
        /**
         * done 回调。该回调需开发者自定义。
         */
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null) => void;
    }): void;
    /**
     *
     * <h4>描述</h4>
     *
     * 撤回消息。
     *
     * <h4>使用场景</h4>
     *
     * 消息发送后的可撤回时长（默认 2 分钟，可在云信控制台配置）内，发送方撤回已发送的单聊消息或者群消息。
     *
     * <ul>
     * <li>单聊场景下，发送方撤回之后，对应的离线消息、漫游消息和历史消息将被删除，消息接收方会收到一条类型为 deleteMsg 的系统通知。</li>
     * <li>群聊场景下, 所有群成员都会收到类型为 deleteMsg 的系统通知。</li>
     * <li>如果发送方同时在多个端登录了同一个 IM 账号, 那么其它端也会收到类型为 deleteMsg 的系统通知。</li></ul>
     *
     * <h4>注意</h4>
     *
     * 单聊和群聊消息的撤回功能存在些许区别：
     *
     * <ul><li>单聊：用户只能撤回自己发送的消息。</li><li>群聊：普通成员只能撤回自己发送的消息。管理员可撤回其他群成员的消息。</li></ul>
     *
     * <h4>使用限制</h4>
     *
     * <ul><li>如果消息发送失败或者消息发送者被拉黑，那么即使在可撤回时长内也无法撤回。</li><li>消息撤回后，无论是发送方还是接收方，都无法在历史消息、漫游消息或者离线消息的接口返回中，查到该消息。</li><li>以下情况下，消息撤回会失败：消息为空、消息没有发送成功、消息超过撤回时限，或者消息被反垃圾（内容审核）命中时。</li></ul>
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onsysmsg}</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesessions}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E6%92%A4%E5%9B%9E%E6%B6%88%E6%81%AF.js" target="_blank">撤回消息</a></li>
     * </ul>
     */
    recallMsg(options: {
        /**
         * 待撤回的消息
         */
        msg: NIMMessage;
        /**
         * 自定义推送文案
         */
        apnsText?: string;
        /**
         * 第三方自定义的推送属性，限制使用 JSON 格式化的字符串。更多说明及相关示例请参见<a href="https://doc.yunxin.163.com/messaging/docs/DQyNjc5NjE?platform=server" target="_blank">推送payload配置</a>
         */
        pushPayload?: string;
        /**
         * 附言
         */
        ps?: string;
        /**
         * 附加信息，推荐使用 JSON 格式化字符串
         */
        attach?: string;
        /**
         * 指定当前消息需要抄送到或者回调到的环境的名称。开通消息抄送或第三方回调后，该环境名称可在云信控制台中配置（如下图），最大 32 个字符。
         *
         *
         * @note
         *
         * <br>
         *
         * <ul><li>开通与配置消息抄送功能的详情，请参见<a href="https://doc.yunxin.163.com/messaging/docs/jY5MDk1NTQ?platform=server" target="_blank">开通消息抄送</a>。</li>
         *
         * <li>第三方回调相关详情，请参见<a href="https://doc.yunxin.163.com/messaging/docs/jI3ODc2ODE?platform=server" target="_blank">第三方回调概述</a>。</li></ul>
         *
         * <img style="max-width:100%;" src="https://yx-web-nosdn.netease.im/common/67dfaa431a321abfb77e5f238da47b62/自定义抄送环境.png" />
         */
        env?: string;
        /**
         * done 回调。该回调需开发者自定义。
         */
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null) => void;
    }): void;
    /**
     * 单向删除一条消息。删除后，消息对于其它用户仍可见。多端登录时，该函数会触发其它端 {@link NIMGetInstanceOptions.onDeleteMsgSelf | onDeleteMsgSelf} 的回调
     */
    deleteMsgSelf(options: {
        /**
         * 待删除的消息
         */
        msg: NIMMessage;
        /**
         * 扩展字段
         */
        custom?: string;
        /**
         * done 回调。该回调需开发者自定义
         */
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null) => void;
    }): void;
    /**
     * 批量单向删除一条消息。删除后，消息对于其它用户仍可见。多端登录时，该函数会触发其它端 {@link NIMGetInstanceOptions.onDeleteMsgSelf | onDeleteMsgSelf} 的回调
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E5%8D%95%E5%90%91%E5%88%A0%E9%99%A4%E6%B6%88%E6%81%AF.js" target="_blank">单向删除消息</a></li>
     * </ul>
     *
     */
    deleteMsgSelfBatch(options: {
        /**
         * 待删除的消息列表
         */
        msgs: NIMMessage[];
        /**
         * 扩展字段
         */
        custom?: string;
        /**
         * done 回调。该回调需开发者自定义
         */
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null) => void;
    }): void;
    /**
     * @deprecated 标记消息已接收。消息从离线状态变为漫游状态。此接口废弃，新增初始化参数 {@link NIMGetInstanceOptions.autoMarkRead | autoMarkRead } 自动调用此函数
     */
    markMsgRead(options: {
        msgs: NIMMessage[];
        done?: (err: NIMCommonError | Error | NIMStrAnyObj | null) => void;
    }): void;
    /**
     * @deprecated  此接口用于查询p2p消息是否已接收已读回执，目前已废弃
     *
     * <h4>查询已读回执</h4>
     * 如何判断消息是否接收已读回执？当 msg.scene === 'p2p' && msg.flow === 'out' && msg.time <= session.msgReceiptTime 时，即可认为消息已收到已读回执
     */
    isMsgRemoteRead(options: {
        msg: NIMMessage;
    }): boolean;
}
export interface NIMTeamMsgReceipts {
    /**
     * 群 id
     */
    teamId: string;
    /**
     * 消息的 {@link NIMMessage.idServer | idServer}
     */
    idServer: string;
    /**
     * 此消息已读数
     *
     * 注: 由于历史问题这个参数定义为字符串，但是可以转为数字类型
     */
    read?: string;
    /**
     * 此消息未读数
     *
     * 注: 由于历史问题这个参数定义为字符串，但是可以转为数字类型
     */
    unread?: string;
    /**
     * 消息的 {@link NIMMessage.idClient | idClient}
     */
    idClient?: string;
}
export interface NIMGetTeamMsgReadAccountsResult {
    /**
     * 已读消息的相关信息
     */
    teamMsgReceipt: NIMTeamMsgReceipts;
    /**
     * 已读账号列表
     */
    readAccounts: string[];
    /**
     * 未读账号列表
     */
    unreadAccounts: string[];
}
export interface NIMResendMsgOptions extends NIMBaseUploadFileOptions {
    /**
     * 待重发的消息。
     *
     * 注：消息体中含有 idClient，且 status 不为 success 的才会重发。
     *
     * 注2: 消息发送成功后，done 回调第二个参数是一个正常的 NIMMessage 体；而若上传阶段失败了，返回的是 NIMSendFileFailedResult 的结构。
     */
    msg: NIMMessage;
    done?: (err: NIMCommonError | Error | NIMStrAnyObj | null, data: NIMMessage | NIMSendFileFailedResult) => void;
}
export interface NIMBaseSendMsgOptions {
    /**
     * 消息场景
     */
    scene: NIMMsgScene;
    /**
     * 接收方信息
     *
     * <ul><li>单聊场景下为消息接收方的 IM 帐号(accid)</li><li>群聊或超大群场景下为群 ID</li></ul>
     */
    to: string;
    /**
     * 是否是重发。如果是重发，还需要额外带上消息的 flow 和 status
     */
    /**
     * 如果是重发, 那么需要带上之前生成的 idClient 来标记这条消息
     */
    /**
     * 扩展字段
     *
     * 注：推荐使用 JSON 序列化字符串
     */
    custom?: string;
    /**
     * 自定义推送文案
     */
    pushContent?: string;
    /**
     * 自定义的推送属性。更多说明及相关示例请参见<a href="https://doc.yunxin.163.com/messaging/docs/DQyNjc5NjE?platform=server" target="_blank">推送payload配置</a>
     *
     * 注：必须使用 JSON 序列化字符串
     */
    pushPayload?: string;
    /**
     * 是否需要推送昵称，默认 true
     */
    needPushNick?: boolean;
    /**
     * 是否存储云端历史，默认 true
     */
    isHistoryable?: boolean;
    /**
     * 是否支持漫游，默认 true
     */
    isRoamingable?: boolean;
    /**
     * 是否支持发送方多端同步，默认 true
     */
    isSyncable?: boolean;
    /**
     * 是否将消息抄送至指定的第三方服务器（可以是应用服务器），默认 true
     */
    cc?: boolean;
    /**
     * 是否需要推送，默认 true
     */
    isPushable?: boolean;
    /**
     * 是否要存离线，默认 true
     */
    isOfflinable?: boolean;
    /**
     * 是否计入消息未读数，默认 true
     */
    isUnreadable?: boolean;
    /**
     * 特殊推送选项, 只在群会话中使用
     */
    apns?: {
        /**
         * 需要特殊推送的 IM 账号（accid）列表, 不填表示推送给当前会话内的所有用户
         */
        accounts?: string[];
        /**
         * 需要特殊推送的文案, 不填的话默认为 pushContent
         */
        content?: string;
        /**
         * 是否强制推送, true 表示即使推送列表中的用户屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
         */
        forcePush?: boolean;
    };
    /**
     * AI自动对话机器人消息
     */
    robotInfo?: {
        /**
         * 指定机器人具体功能，用户填写
         */
        function: string;
        /**
         * 指定话题，用户填写
         */
        topic: string;
        /**
         * 指定自定义内容，用户填写
         */
        customContent: string;
        /**
         * 指定机器人账号，用户填写。(仅在群聊中有效，p2p会被忽略)
         */
        account?: string;
    };
    /**
     * 是否是本地消息，默认 false
     *
     * 注：此参数为 true，sdk 仅仅只是把消息存入库，不会发往 NIM 服务器
     */
    isLocal?: boolean;
    /**
     * 本地消息的发送方，默认是当前用户.
     *
     * isLocal 为 true 时生效。
     */
    localFrom?: string;
    /**
     * 是否需要业务已读，默认 false。该参数仅在群聊时生效，单聊时无需设置
     *
     * 注：msgReceipt 指的是本端发送的消息，对端是不是已读了本端的消息。
     */
    needMsgReceipt?: boolean;
    /**
     * 是否需要通过客户端反垃圾对该消息进行内容审核，默认 false
     */
    clientAntiSpam?: boolean;
    /**
     * 是否需要对自定义消息的指定内容（antiSpamContent）进行安全检测，默认 false
     */
    yidunEnable?: boolean;
    /**
     * 自定义消息中需额外进行审核的内容，yidunEnable 开启后才能配置该参数，且仅对自定义消息有效。必须传递 JSON 格式字符串，长度不超过 5,000 字节
     *
     * 格式如下：{"type": 1, "data": "custom content"}
     *
     * 字段说明：
     *
     * <ul><li>type: 1-文本、2-图片、3-视频</li><li>data: 内容可以是文本内容、图片地址、视频地址</li></ul>
     */
    antiSpamContent?: string;
    /**
     * 安全通自定义业务 ID，传入此参数则消息通过安全通自定义业务进行安全审核；如需新增安全通自定义业务，请联系商务经理进行相关配置，然后前往云信控制台的安全通配置界面获取该业务 ID。
     */
    antiSpamBusinessId?: string;
    /**
     * 是否使用安全通对当前消息进行内容安全检测，默认 true
     */
    antiSpamUsingYidun?: boolean;
    /**
     * 是否需要刷新远端的服务器会话列表，默认是（请注意区分两种会话），默认为 true
     */
    needUpdateSession?: boolean;
    /**
     * 要回复的消息对象，表示当前消息是对某条消息的回复
     */
    replyMsg?: NIMMessage;
    /**
     * 易盾反作弊字段，长度限制1024，JSON 序列化字符串。
     *
     * 如："{"email":"test@163.com","phone":"12345678901","token":"1234","extension":"hello"}"
     */
    yidunAntiCheating?: string;
    /**
     * 易盾反作弊扩展字段字段，2021-08-09 追加。JSON 序列化字符串，长度上限 1024
     */
    yidunAntiSpamExt?: string;
    /**
     * 消息子类型。格式为大于0的整数，开发者需要自行映射其含义
     */
    subType?: number;
    /**
     * 指定当前消息需要抄送到或者回调到的环境的名称。开通消息抄送或第三方回调后，该环境名称可在云信控制台中配置（如下图），最大 32 个字符。
     *
     *
     * @note
     *
     * <br>
     *
     * <ul><li>开通与配置消息抄送功能的详情，请参见<a href="https://doc.yunxin.163.com/messaging/docs/jY5MDk1NTQ?platform=server" target="_blank">开通消息抄送</a>。</li><li>第三方回调相关详情，请参见<a href="https://doc.yunxin.163.com/messaging/docs/jI3ODc2ODE?platform=server" target="_blank">第三方回调概述</a>。</li></ul>
     *
     * <img style="max-width:100%;" src="https://yx-web-nosdn.netease.im/common/67dfaa431a321abfb77e5f238da47b62/自定义抄送环境.png" />
     */
    env?: string;
    /**
     * 消息构建完成，在发送前触发的回调
     *
     * 注：此时 idClient 已经构建完毕，status 为 sending，time 为端测本地时间。
     */
    beforesend?: (message: NIMMessage) => void;
    /**
     * 消息发送成功回调
     *
     * 注：接到 NIM 服务器回包后，传回 idServer，更正 status 为 success，time 更正为服务器侧的发送时间。
     */
    done?: (err: NIMCommonError | Error | NIMStrAnyObj | null, data: NIMMessage) => void;
}
export interface NIMSendTipMsgOptions extends NIMBaseSendMsgOptions {
    /**
     * 提醒内容
     */
    tip: string;
}
export interface NIMSendGEOOptions extends NIMBaseSendMsgOptions {
    /**
     * 地理位置
     */
    geo: NIMMsgGEO;
}
export interface NIMSendCustomMsgOptions extends NIMBaseSendMsgOptions {
    /**
     * 自定义消息的消息内容，推荐使用 JSON 序列化字符串
     */
    content: string;
}
export interface NIMSendFileOptions extends NIMBaseUploadFileOptions, NIMBaseSendMsgOptions {
    /**
     * 通过 previewFile 接口上传图片后拿到的对象。
     *
     * 注：如果有需要的话，通过 previewFile 接口上传图片后，在通过 sendFile 接口发送这个 file 参数。
     *
     * 注2: fileInput、file、filePath、blob 只需要填一个
     */
    file?: NIMUploadFileResult;
    /**
     * 开始上传文件的回调。
     *
     * 这个回调接收一个参数叫 upload，调用 upload.abort() 可以取消文件上传。
     *
     * 注: 第二个参数 message 在 9.11.0 之后开始支持
     *
     * 注2: 此方法仅浏览器与微信小程序支持。
     */
    beginupload?: (upload: {
        abort: () => void;
        [key: string]: any;
    }, message: NIMMessage) => void;
    /**
     * 上传进度监听回调
     *
     * 注: 第二个参数 message 在 9.11.0 之后开始支持
     *
     * 注2: 此方法仅浏览器与微信小程序支持。且不要在 IE9 及以下的浏览器版本使用，因为存在兼容性问题
     */
    uploadprogress?: (obj: NIMUploadFileProgressObject, message: NIMMessage) => void;
    /**
     * 上传完毕的回调
     *
     * 注: 第三个参数 message 在 9.11.0 之后开始支持
     *
     * 注2: 第三个参数仅浏览器与微信小程序支持
     */
    uploaddone?: (error: Error | null, obj: NIMUploadFileResult, message: NIMMessage) => void;
    /**
     * 消息发送成功回调
     *
     * 注: 接到 NIM 服务器回包后，传回 idServer，更正 status 为 success，time 更正为服务器侧的发送时间。
     *
     * 注2: 消息发送成功后，done 回调第二个参数是一个正常的 NIMMessage 体；而若上传阶段失败了，返回的是 NIMSendFileFailedResult 的结构。
     */
    done?: (err: NIMCommonError | Error | NIMStrAnyObj | null, data: NIMMessage | NIMSendFileFailedResult) => void;
}
export interface NIMSendFileFailedResult extends NIMBaseUploadFileOptions {
    msg: NIMMessage;
}
export interface NIMSendTextOptions extends NIMBaseSendMsgOptions {
    /**
     * 文本消息内容
     */
    text: string;
}
export declare enum NIMEnumMsgScene {
    p2p = 0,
    team = 1,
    superTeam = 5
}
/**
 * 消息的场景
 */
export declare type NIMMsgScene = keyof typeof NIMEnumMsgScene;
export declare enum NIMEnumMsgType {
    text = 0,
    image = 1,
    audio = 2,
    video = 3,
    geo = 4,
    notification = 5,
    file = 6,
    tip = 10,
    robot = 11,
    g2 = 12,
    custom = 100
}
export declare type NIMMsgType = keyof typeof NIMEnumMsgType;
/**
 * 更新群，禁言群时的通知消息
 */
export declare type NIMMsgAttachUpdateTeam = {
    type: 'updateTeam' | 'updateSuperTeam';
    /**
     * 更新的字段
     */
    team: Partial<NIMTeam>;
    users: Array<NIMUserNameCard>;
};
/**
 * 添加群成员时候的通知消息
 */
export declare type NIMMsgAttachAddTeamMember = {
    type: 'addTeamMembers' | 'addSuperTeamMembers';
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 新加入的成员账号
     */
    accounts: Array<string>;
    /**
     * 新加入的成员信息。注意该信息是成员在群里的信息
     */
    members: Array<NIMTeamMember>;
    /**
     * 操作者和被操作者的名片
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 删除群成员时候的通知消息
 */
export declare type NIMMsgAttachRemoveTeamMembers = {
    type: 'removeTeamMembers' | 'removeSuperTeamMembers';
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 被删除的成员账号
     */
    accounts: Array<string>;
    /**
     * 操作者和被操作者的名片
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 同意群邀请时的通知消息
 */
export declare type NIMMsgAttachAcceptTeamInvite = {
    type: 'acceptTeamInvite' | 'acceptSuperTeamInvite';
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 邀请人账号
     */
    account: string;
    /**
     * 新加入的成员信息。注意该信息是成员在群里的信息
     */
    members: Array<NIMTeamMember>;
    /**
     * 邀请人和接受邀请的人的名片
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 通过群申请时的通知消息
 */
export declare type NIMMsgAttachPassTeamApply = {
    type: 'passTeamApply' | 'passSuperTeamApply';
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 申请人账号
     */
    account: string;
    /**
     * 新加入的成员信息。注意该信息是成员在群里的信息
     */
    members: Array<NIMTeamMember>;
    /**
     * 申请人和同意申请人的名片
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 添加群管理员时的通知消息
 */
export declare type NIMMsgAttachAddTeamManagers = {
    type: 'addTeamManagers' | 'addSuperTeamManagers';
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 新增管理员账号列表
     */
    accounts: Array<string>;
    /**
     * 新增管理员在群里的信息
     */
    members: Array<NIMTeamMember>;
    /**
     * 新增管理员的名片，以及操作者名片
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 删除群管理员时的通知消息
 */
export declare type NIMMsgAttachRemoveTeamManagers = {
    type: 'removeTeamManagers' | 'removeSuperTeamManagers';
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 被移除管理员账号列表
     */
    accounts: Array<string>;
    /**
     * 被移除管理员在群里的信息
     */
    members: Array<NIMTeamMember>;
    /**
     * 被移除管理员的名片，以及操作者名片
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 离开群组时的通知消息
 */
export declare type NIMMsgAttachLeaveTeam = {
    type: 'leaveTeam' | 'leaveSuperTeam';
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 离开群的账号
     */
    users: Array<NIMUserNameCard>;
};
export declare type NIMMsgAttachDismissTeam = {
    type: 'dismissTeam' | 'dismissSuperTeam';
    /**
     * 解散者名片信息
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 转让群组时的通知消息
 */
export declare type NIMMsgAttachTransferTeam = {
    type: 'transferTeam' | 'transferSuperTeam';
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 原群主
     */
    account: string;
    /**
     * 新老群主在群内信息
     */
    members: Array<NIMTeamMember>;
    /**
     * 新老群主名片信息
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 更新群成员禁言状态时的通知消息 (updateMuteStateInTeam)
 */
export declare type NIMMsgAttachUpdateTeamMute = {
    type: 'updateTeamMute';
    /**
     * 指定群成员是否被禁言
     */
    mute: boolean;
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 被禁言/解除禁言者的账号
     */
    account: string;
    /**
     * 被禁言/解除禁言者的群成员信息
     */
    members: Array<NIMTeamMember>;
    /**
     * 被禁言/解除禁言者的名片 + 操作者的名片
     */
    users: Array<NIMUserNameCard>;
};
/**
 * 更新超级群成员禁言状态时的通知消息 (updateSuperTeamMembersMute)
 */
export declare type NIMMsgAttachUpdateSuperTeamMembersMute = {
    type: 'updateSuperTeamMembersMute';
    /**
     * 指定群成员是否被禁言
     */
    mute: boolean;
    /**
     * 群信息
     */
    team: NIMTeam;
    /**
     * 被禁言/解除禁言者的账号
     */
    accounts: Array<string>;
    /**
     * 被禁言/解除禁言者的群成员信息
     */
    members: Array<NIMTeamMember>;
    /**
     * 被禁言/解除禁言者的名片 + 操作者的名片
     */
    users: Array<NIMUserNameCard>;
};
export declare type NIMMessageAttach = NIMMsgAttachUpdateTeam | NIMMsgAttachAddTeamMember | NIMMsgAttachRemoveTeamMembers | NIMMsgAttachAcceptTeamInvite | NIMMsgAttachPassTeamApply | NIMMsgAttachAddTeamManagers | NIMMsgAttachRemoveTeamManagers | NIMMsgAttachLeaveTeam | NIMMsgAttachDismissTeam | NIMMsgAttachTransferTeam | NIMMsgAttachUpdateTeamMute | NIMMsgAttachUpdateSuperTeamMembersMute;
/**
 * 单聊、群聊和超大群的消息体
 */
export interface NIMMessage {
    /**
     * 消息场景：
     *
     * <ul><li>p2p：单聊场景</li><li>team：群聊场景</li><li>superteam：超大群场景</li></ul>
     */
    scene: NIMMsgScene;
    /**
     * 消息发送方, 帐号
     */
    from: string;
    /**
     * 消息发送方的昵称
     */
    fromNick?: string;
    /**
     * 发送方的设备类型
     */
    fromClientType?: string;
    /**
     * 发送端设备id
     */
    fromDeviceId?: string;
    /**
     * 消息接收方, 帐号或群id
     */
    to: string;
    /**
     * 时间戳
     */
    time: number;
    /**
     * 发送方信息更新时间
     */
    userUpdateTime: number;
    /**
     * 消息类型
     */
    type: NIMMsgType;
    /**
     * 消息所属的会话的ID
     */
    sessionId: string;
    /**
     * 聊天对象, 账号或者群id
     */
    target: string;
    /**
     * 消息的流向
     *
     * 'in' 代表这是收到的消息.
     * 'out' 代表这是发出的消息
     */
    flow: string;
    /**
     * 消息发送状态
     *
     * 'sending' 发送中
     * 'success' 发送成功
     * 'fail' 发送失败
     */
    status: string;
    /**
     * 端测生成的消息id, 可作为消息唯一主键使用。
     */
    idClient: string;
    /**
     * 服务器用于区分消息用的ID, 用于获取历史消息和获取包含关键词的历史消息。
     *
     * 注：此字段可能没有, 比如说消息被反垃圾过滤了。
     */
    idServer?: string;
    /**
     * 文本消息的文本内容. 当 type 为 text 时存在
     */
    text?: string;
    /**
     * 文件消息的文件对象. 当 type 为 image, audio, video, file 时，且 status 为 success 时存在
     */
    file?: NIMUploadFileResult;
    /**
     * 地理位置消息的地理位置对象. 当 type 为 geo 时存在
     */
    geo?: NIMMsgGEO;
    /**
     * 提醒消息的内容. 当 type 为 tip 时存在
     */
    tip?: string;
    /**
     * 自定义消息的消息内容, 开发者可以自行扩展, 建议封装成 JSON 序列化后的字符串. 当 type 为 custom 时存在
     */
    content?: string;
    /**
     * 群通知消息的附加信息。当 type 为 notification 时存在
     */
    attach?: NIMMessageAttach;
    /**
     * 该消息在接收方是否应该被静音
     */
    isMuted?: boolean;
    /**
     * 是否是重发的消息，默认是 false
     */
    resend?: boolean;
    /**
     * 扩展字段
     *
     * 注：推荐传入 JSON 序列化的字符串
     */
    custom?: string;
    /**
     * 自定义推送文案
     */
    pushContent?: string;
    /**
     * 自定义的推送属性。更多说明及相关示例请参见<a href="https://doc.yunxin.163.com/messaging/docs/DQyNjc5NjE?platform=server" target="_blank">推送payload配置</a>
     *
     * 注：必须传入 JSON 序列化的字符串
     */
    pushPayload?: string;
    /**
     * 特殊推送选项, 只在群会话中使用
     */
    apns?: {
        /**
         * 需要特殊推送的账号列表, 此字段不存在的话表示推送给当前会话内的所有用户
         */
        accounts?: string[];
        /**
         * 需要特殊推送的文案
         */
        content?: string;
        /**
         * 是否强制推送, 默认 false
         *
         * true 表示即使推送列表中的用户屏蔽了当前会话（如静音）, 仍能够推送当前这条内容给相应用户
         */
        forcePush?: boolean;
    };
    /**
     * 本地数据库自定义扩展字段，开启 db 时有效。
     */
    localCustom?: string;
    /**
     * 发送方 'from' 是否在接收方 'to' 的黑名单列表中
     */
    isInBlackList?: boolean;
    /**
     * 是否存储云端历史，默认 true
     */
    isHistoryable?: boolean;
    /**
     * 是否支持漫游，默认 true
     */
    isRoamingable?: boolean;
    /**
     * 是否支持发送者多端同步，默认 true
     */
    isSyncable?: boolean;
    /**
     * 是否支持抄送，默认 true
     */
    cc?: boolean;
    /**
     * 是否需要推送，默认 true
     */
    isPushable?: boolean;
    /**
     * 是否要存离线，默认 true
     */
    isOfflinable?: boolean;
    /**
     * 是否计入消息未读数，默认 true
     */
    isUnreadable?: boolean;
    /**
     * 是否为应答消息（用于机器人等类似场景等应答消息内容）
     */
    isReplyMsg?: boolean;
    /**
     * 群已读消息快照大小（即消息发送时的群人数-1）
     */
    tempTeamMemberCount?: number;
    /**
     * 是否需要推送昵称
     */
    needPushNick?: boolean;
    /**
     * 是否需要刷新服务器会话列表，默认是true
     */
    needUpdateSession?: boolean;
    /**
     * 是否是本地数据库消息, 默认 false
     */
    isLocal?: boolean;
    /**
     * 被回复消息的发送者账号
     */
    replyMsgFromAccount?: string;
    /**
     * 被回复消息的接受者账号
     */
    replyMsgToAccount?: string;
    /**
     * 被回复消息的时间
     */
    replyMsgTime?: number;
    /**
     * 被回复消息的 idServer
     */
    replyMsgIdServer?: string;
    /**
     * 被回复消息的 idClient
     */
    replyMsgIdClient?: string;
    /**
     * thread 消息的发送者账号
     */
    threadMsgFromAccount?: string;
    /**
     * thread消息的接受者账号
     */
    threadMsgToAccount?: string;
    /**
     * thread消息的时间
     */
    threadMsgTime?: number;
    /**
     * thread消息的idServer
     */
    threadMsgIdServer?: string;
    /**
     * thread消息的idClient
     */
    threadMsgIdClient?: string;
    /**
     * 该消息是否已被撤回或单向删除，获取 thread 消息列表时会用到
     */
    delete?: boolean;
    /**
     * <a href="https://doc.yunxin.163.com/messaging/docs/jI3ODc2ODE?platform=server" target="_blank">第三方回调</a>的扩展字段
     */
    callbackExt?: string;
    /**
     * 开发者自定义的消息子类型，格式为大于0的整数
     */
    subType?: number;
    /**
     * 指定当前消息需要抄送到或者回调到的环境的名称。开通消息抄送或第三方回调后，该环境名称可在云信控制台中配置（如下图），最大 32 个字符。
     *
     *
     * @note
     *
     * <br>
     *
     * <ul><li>开通与配置消息抄送功能的详情，请参见<a href="https://doc.yunxin.163.com/messaging/docs/jY5MDk1NTQ?platform=server" target="_blank">开通消息抄送</a>。</li>
     *
     * <li>第三方回调相关详情，请参见<a href="https://doc.yunxin.163.com/messaging/docs/jI3ODc2ODE?platform=server" target="_blank">第三方回调概述</a>。</li></ul>
     *
     * <img style="max-width:100%;" src="https://yx-web-nosdn.netease.im/common/67dfaa431a321abfb77e5f238da47b62/自定义抄送环境.png" />
     */
    env?: string;
    /**
     * 易盾反垃圾结果。
     *
     * 注：若开启了易盾反垃圾，并且针对文本或图片如果被反垃圾策略匹配中，端测会透传此反垃圾结果字段。
     */
    yidunAntiSpamRes?: string;
}
export interface NIMMsgGEO {
    /**
     * 地点名
     */
    title: string;
    /**
     * 纬度坐标
     */
    lat: number;
    /**
     * 经度坐标
     */
    lng: number;
}
export declare type NIMTeamMsgReceipt = {
    teamId: string;
    /**
     * 消息的 idServer
     */
    idServer: string;
    /**
     * 消息的 idServer
     */
    idClient: string;
    /**
     * 当前已标记 receipt 的人数
     */
    read: number;
    /**
     * 当前未标记 receipt 的人数
     */
    unread: number;
    /**
     * 当前标记 receipt 者的账号 account ID
     */
    account: string;
};
export declare type NIMP2PMsgReceipt = {
    sessionId: string;
    /**
     * 消息的 idServer
     */
    idClient: string;
    /**
     * 消息被读时间
     */
    msgReceiptTime: number;
};
export interface NIMBroadcastMessage {
    /**
     * 广播内容
     */
    body: string;
    /**
     * 广播消息的 id
     */
    broadcastId: string;
    /**
     * 发送者的账号 id
     */
    fromAccid: string;
    /**
     * 发送者的 uid
     */
    fromUid: string;
    /**
     * 发送时间戳，可以进一步的解析为数字
     */
    timestamp: string;
    /**
     * 等同于上面的 timestamp
     */
    time: string;
}
