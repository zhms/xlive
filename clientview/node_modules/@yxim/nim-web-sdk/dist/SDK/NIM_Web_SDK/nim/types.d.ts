import { NIMStrAnyObj } from '../types';
import { NIMCloudSession } from './CloudSessionInterface';
import { NIMPushEventInfo } from './EventInterface';
import { NIMFriendProfile } from './FriendInterface';
import { NIMBroadcastMessage, NIMMessage, NIMTeamMsgReceipt, NIMP2PMsgReceipt, NIMMsgScene } from './MessageInterface';
import { NIMMsgPinInfo } from './MessageExtendInterface';
import { NIMSession } from './SessionInterface';
import { NIMSuperTeam, NIMSuperTeamMember } from './SuperTeamInterface';
import { NIMSystemMessage, NIMSystemMessageUnreadInfo } from './SystemMessageInterface';
import { NIMOnUpdateTeamResult1, NIMOnUpdateTeamResult2, NIMOnUpdateTeamResult3, NIMTeam, NIMTeamMember } from './TeamInterface';
import { NIMUserNameCard } from './UserInterface';
export interface NIMGetInstanceOptions {
    /**
     * 应用的 App Key，即您的应用在云信的账号。
     *
     * @note 您可在云信控制台创建 App Key。详情参见<a href="https://doc.yunxin.163.com/messaging/docs/Dk0MjM3ODA?platform=web" target="_blank">创建应用</a>。
     *
     */
    appKey: string;
    /**
     * 云信 IM 账号（又称 accid），即应用的用户在云信的唯一标识。
     *
     * @notice 应用本身的用户帐号和云信的 IM 账号（accid）彼此独立。云信的 IM 账号只用于云信 IM 服务的鉴权，IM 账号并不等同于应用的用户账号。
     */
    account: string;
    /**
     * IM 账号的登录凭证。该登录凭证只会在登录 IM （建立 SDK 与云信服务端的长连接）时校验一次。
     */
    token: string;
    /**
     * 登录 IM 的鉴权方式（默认为 0）：
     *
     * <ul><li>0：通过传入静态 token 进行鉴权。静态 token 恒定不变，且默认永久有效，除非主动调用云信服务端 API <a href="https://doc.yunxin.163.com/messaging/docs/DUxNDQ3NjA?platform=server" target="_blank">刷新 token</a>。</li>
     * <li>1：通过传入动态 token 进行鉴权。动态 token 可设置有效期，因此具备时效性。采用该鉴权方式可有效提升token 破解难度，降低密码泄露风险。动态鉴权生成方式请参考: <a href="https://doc.yunxin.163.com/messaging/docs/zE2NzA3Mjc?platform=server#%E5%8A%A8%E6%80%81token%E9%89%B4%E6%9D%83" target="_blank">服务器动态token</a></li>
     * <li>2：过云信的第三方回调功能进行鉴权。云信服务端不做 IM 登录鉴权，鉴权工作需由指定的第三方服务器（可以是应用服务器）进行。</li></ul>
     *
     * 注意如果使用 动态token 鉴权，需要监听 onwillreconnect 回调，并在 onwillreconnect 中设置动态 token
     *
     * @note 具体的 token 获取方式和相关登录方式，请参见<a href="https://doc.yunxin.163.com/messaging/docs/zE0NDY4Njc?platform=web" target="_blank">初始化与登录</a>。
     */
    authType?: number;
    /**
     * 是否需要开启 XHR 请求，默认 true
     *
     * v9.12.0 新增
     *
     * 注: 开启 XHR 请求，如 socket.io 机制，会在建立长连接前从 IM 服务器获取一个长连接 ID，以及建议的连接通道 [websocket, xhr-polling] 等.
     *
     * 建议非 IE 兼容需求的可以设置为 false, 在 IE 6～10 里此设置无效，必定会走 true 的逻辑。
     *
     * 追加注: 因为服务器在建连后的协议里，无法区分究竟是 xhr-polling 连接还是 websocket 连接发出的协议。
     * 并且 xhr-polling ，若跳过 sessionId 校验，有一些漏洞能被攻击者利用。
     * 所以开关直接隐藏但是代码保留，服务器根据有需要的人部署独立的 weblink 集群只给此客户使用，风险自己承担。
     */
    /**
     * socket 并发连接数。
     *
     * 自从 v9.12.0 开始支持
     * Socket 并发连接数上限。仅支持设置为 1-3 的整数。默认值为1，表示不支持并发连接。
     * 如果您需要加快 Socket  连接，建议您设置该参数。
     */
    socketConcurrent?: number;
    /**
     * 登录自定义扩展字段，可转发给指定的第三方服务器，不会同步至其他端。authType为 2，即通过第三方回调进行 IM 登录鉴权时，必须传入，用于第三方服务器鉴权。
     *
     * @note 第三方回调鉴权相关说明，请参见<a href="https://doc.yunxin.163.com/messaging/docs/zE0NDY4Njc?platform=web#通过第三方回调登录" target="_blank">通过第三方回调登录</a>。
     *
     */
    loginExt?: string;
    /**
     * 是否打印调试日志。默认为false，即不打印日志
     *
     * @deprecated 推荐使用logLevel控制日志打印级别
     *
     * @note 注意，该属性仅影响控制台日志是否开启，不会影响存储在indexdb中的日志级别。
     *
     */
    debug?: boolean;
    /**
     * 日志级别，默认为 off，即不输出任何日志。该属性会同时影响indexdb和控制台中的日志级别
     *
     * - off：不输出任何日志
     * - debug：输出debug、info、warn 和 error 级别的日志
     * - info：输出 info、warn、和 error 级别的日志
     * - warn：输出 warn 和 error 级别的日志
     * - error：输出 error 级别的日志
     *
     */
    logLevel?: 'debug' | 'info' | 'warn' | 'error' | 'off';
    /**
     * 默认的备用长连接地址
     *
     * @notice 当 LBS 请求出错时，NIM SDK会尝试该长连接地址。若不传此参数，长连接地址默认为云信的公网备用地址。
     */
    defaultLink?: string;
    /**
     * 默认使用的 LBS 连接地址
     *
     * @notice NIM SDK 需要先请求 LBS 地址才能获取到与云信服务端的长连接地址，再建立长连接。若不传此参数，长连接地址默认为云信的公网备用地址。
     */
    lbsUrl?: string;
    /**
     * 是否开启备用 LBS 地址，默认为 true，即 NIM SDK 会将上一次连接成功的 LBS 地址存储到浏览器本地缓存 localStorage 作为备用，当主 LBS 不可用时，会尝试请求备用 LBS 地址进行连接。
     */
    lbsBackup?: boolean;
    /**
     * 自定义的备用 LBS 地址数组，用于自定义接口去代理 LBS 返回，防止运营商劫持。当主 LBS 不可用且浏览器本地缓存的备用 LBS 地址均不可用时，NIM SDK 会尝试请求自定义的备用 LBS ，优先级比lbsBackup 提到的 localstorage 里缓存的低。
     */
    lbsBackupUrlsCustomer?: string[];
    /**
     * 上传的文件在 NOS 上的存储场景。
     *
     * #### 常见说明
     * - 常用场景为根据资源类型设置存储场景，然后设置定时任务调用 <a target="_blank" href="https://doc.yunxin.163.com/messaging/docs/zQyNDM0NzE?platform=server#%E6%B8%85%E7%90%86%E5%B7%B2%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6">清理文件</a> 删除。
     * - IM 默认的存储场景为: 'im'
     * - Chatroom 默认的存储场景为: 'chatroom'
     *
     * #### 存储场景优先级
     * - sendFile 或者 previewFile 时的 nosScene 参数
     * - 初始化参数的 nosScene 参数
     * - 默认参数: 'im' 或者 'chatroom'
     *
     * #### 私有化安全链接
     * - 私有化生成安全链接，请设置 nosScene: '_nim_security'
     * - 接收方使用 getNosAccessToken 获取带有鉴权信息的链接
     * - 使用 deleteNosAccessToken 设置鉴权信息无效
     *
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageInterface.sendFile}</li>
     * <li>{@link CloudStorageInterface.previewFile}</li>
     * <li>{@link CloudStorageInterface.getNosAccessToken}</li>
     * <li>{@link CloudStorageInterface.deleteNosAccessToken}</li>
     * </ul>
     *
     */
    nosScene?: string;
    /**
     * 上传的文件在网易云存储服务（NetEase Object Storage, NOS）上的存储有效期。
     *
     * @notice 默认为 Infinity（永久）。设置的时间不得小于一天，单位：秒。
     *
     */
    nosSurvivalTime?: number;
    /**
     * 客户端自定义 tag。最多 32 个字符。
     *
     * 多端登录场景下，如果某个设备端登录时设置了该字段，其他设备端可通过 onloginportschange 回调获取该字段信息。
     *
     * <h4>关联函数</h4>
     * <li>{@link NIMGetInstanceOptions.onloginportschange}</li>
     *
     * <h4>示例</h4>
     *
     * ```js
     * //设备1
     * NIM.getInstance({
     *   account: 'test1',
     *   onloginportschange: function(err, data) {
     *     //设备2登录时，打印:
     *     //data: [{
     *     //  account: 'test1',
     *     //  customTag: 'customTag from test1',
     *     //  connectionId, deviceId, ip, mac, online, os, time, type
     *     //}]
     *     console.log('data', data)
     *   }
     * })
     *
     * //设备2
     * NIM.getInstance({
     *   account: 'test1',
     *   customTag: 'customTag from test1'
     * })
     * ```
     */
    customTag?: string;
    /**
     * 自定义客户端类型，请设置大于 0 的整数。可实现自定义多端登录策略，具体策略可在云信管理后台配置。详情请查看文档: <a href="https://doc.yunxin.163.com/messaging/docs/DU0MzAyMDg?platform=web#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E7%AB%AF%E7%99%BB%E5%BD%95">自定义多端登录</a>
     *
     * @notice 默认端类型只有 Web，PC，AOS，iOS。如果开发者需要更细致的类型区分，如微信小程序等环境，可通过该字段自行做映射。
     */
    customClientType?: string;
    /**
     *
     * 是否自动标记消息为已收到，默认为 true。
     *
     * 如果设置为 false，所有的消息（包括普通消息和系统通知）都不会自动标记已读，需要手动调用标记已读接口 markMsgRead 来告知服务端消息已接收。否则服务器会在初始化时通过离线消息通知，以及离线系统通知通知下发消息。
     *
     *
     * <h4>关联函数</h4>
     * <li>{@link MessageInterface.markMsgRead}</li>
     *
     * @deprecated
     */
    autoMarkRead?: boolean;
    /**
     * 是否使用 IM 业务数据库（采用 indexedDb），默认 true
     *
     * @notice
     *
     * <br>
     *
     * - 请在 onsyncdone 结束后，再调用 db 相关操作。否则可能调用时，db尚未打开
     * - 在 safari 浏览器(桌面端，及iOS系统浏览器)中，使用 SDK 操作数据库时存在一些异常问题，因此 SDK 在移动端 safari 上禁用了数据库。建议移动端浏览器使用 Web SDK 时默认不开启数据库，在初始化时将db设置为 false。
     * - 在支持数据库的浏览器上，SDK 会将消息、会话、群组等数据缓存到 indexedDB 数据库中, 后续同步都是增量更新, 加快初始化同步速度。
     *
     * 若开发时遇到'不支持数据库', 'db::checkDB', 'Not_Support_DB' 等消息，请检查：
     * - 请在 getInstance 回调函数 onsyncdone 结束后调用会使用数据库的操作
     * - 请确保你使用的不是 Safari 浏览器
     */
    db?: boolean;
    /**
     * 是否将日志存储到本地数据库，默认 true，即默认将日志存储到本地数据库。后续如需拉取本地数据库中的日志，请联系云信技术支持。
     *
     * @note 日志数据库与 IM 业务数据库为两个数据库，互不影响。
     */
    dbLog?: boolean;
    /**
     * 本地数据库中的日志有效期。单位：小时，默认为 72 小时。
     *
     * @notice 该字段仅在 dbLog 为 true 时生效。
     */
    expire?: number;
    /**
     * 是否开启自动重连，默认 true，即如果长连接因为网络问题、心跳超时等原因断开，NIM SDK 默认自动尝试重连。
     *
     * @note 重连的时间间隔从 1.6～8s 之间累加，每次重连将触发 onwillreconnect 事件。
     */
    needReconnect?: boolean;
    /**
     * SDK 尝试重连的最大次数，超过后则不再尝试重连。
     *
     * @note 当重连尝试达到最大次数，将结束重连过程，最终触发 ondisconnect 回调，表示彻底断开。
     */
    reconnectionAttempts?: number;
    /**
     * 是否开启快速自动重连，默认 false。若设置为 true，NIM SDK 会监听浏览器的 offline 和 online 事件来嗅探网络断开和恢复，将会做相应的断开和重连策略。
     *
     * @notice 该字段只有在 needReconnect 为 true 时才有效。
     */
    quickReconnect?: boolean;
    /**
     * 撤回消息后是否更新相应会话的未读数，默认 true
     *
     * 假设该参数设置为 true 且某会话有 2 条未读消息，如果其中 1 条消息被撤回了，那么该会话未读数变为 1
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageInterface.deleteMsgSelf}</li>
     * <li>{@link MessageInterface.deleteMsgSelfBatch}</li>
     * <li>{@link MessageLogInterface.deleteLocalMsg}</li>
     * </ul>
     *
     * @deprecated
     */
    rollbackDelMsgUnread?: boolean;
    /**
     * 调用 clearServerHistoryMsgsWithSync 清空历史消息后，是否更新会话未读数以及最后一条消息，并触发 onupdatesessions 回调函数，默认为true。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageLogInterface.clearServerHistoryMsgsWithSync}</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesessions}</li>
     * </ul>
     */
    rollbackClearMsgsUnread?: boolean;
    /**
     * 调用关联函数重置会话未读数失败后，是否需要继续重置当前客户端的未读数，默认为true
     *
     * - true：继续重置当前客户端未读数。注意，此时本地显示未读数，和服务端保存的未读数不一样
     * - false：不重置当前客户端未读数
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link SessionInterface.setCurrSession} 设置当前会话</li>
     * <li>{@link SessionInterface.resetAllSessionUnread} 设置所有会话未读数</li>
     * <li>{@link SessionInterface.resetSessionsUnread} 批量设置会话未读数</li>
     * <li>{@link SessionInterface.resetSessionUnread} 设置会话未读数</li>
     * <li>{@link SessionInterface.resetSuperTeamSessionsUnread} 设置超级群未读数</li>
     * </ul>
     *
     */
    resetUnreadMode?: boolean;
    /**
     * 消息内容里的文件的 CDN 链接是否强制使用 HTTPS 协议。默认 false。
     */
    httpsEnabled?: boolean;
    /**
     * 是否上报异常错误日志，默认 false，即禁止上报错误日志。
     *
     * @notice SDK 会将部分错误及相关信息上传至云信统计平台，方便开发者统计及排查线上错误。
     */
    /**
     * 是否通过 HTTPS 协议跟服务器建立连接, 默认 true
     */
    secure?: boolean;
    /**
     * 是否同步黑名单和静音列表, 默认true。若设置为true，则初始化同步接收黑名单和静音列表
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onblacklist}</li>
     * <li>{@link NIMGetInstanceOptions.onmutelist}</li>
     * </ul>
     */
    syncRelations?: boolean;
    /**
     * - 是否在初始化时同步好友列表, 默认 true
     * - 如果初始化时未同步好友名单, 可以后续通过 {@link FriendInterface.getFriends} 获取好友列表
     *
     * <h4>关联函数</h4>
     * <li>{@link NIMGetInstanceOptions.onfriends}</li>
     */
    syncFriends?: boolean;
    /**
     * 是否在初始化时同步好友对应的用户名片列表, 默认true
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onusers}</li>
     * </ul>
     */
    syncFriendUsers?: boolean;
    /**
     * 是否在初始化时同步超大群列表, 默认true
     *
     * <h4>关联函数</h4>
     * <li>{@link NIMGetInstanceOptions.onSuperTeams}</li>
     */
    syncSuperTeams?: boolean;
    /**
     * - 是否在初始化时同步群列表, 默认 true。
     * - 若传 false 就收不到 onteams 回调，开发者后续可以通过 {@link TeamInterface.getTeams} 获取群列表
     *
     * <h4>关联函数</h4>
     * <li>{@link NIMGetInstanceOptions.onteams}</li>
     *
     */
    syncTeams?: boolean;
    /**
     * 是否在初始化时同步用户在各个群中的信息。默认为true。如果设置为 false，则初始化阶段 `onMyTeamMembers` 不会触发。
     *
     * `onMyTeamMembers` 返回了当前用户在各个群中的信息，包括但不限于：
     * - mute: 当前成员在群内是否静音
     * - muteNotiType: 群消息提醒策略
     * - muteTeam: 群组静音是否开启
     * - nickInTeam: 群内昵称
     * - invitorAccid: 邀请人账号
     *
     * <h4>关联函数</h4>
     * <li>{@link NIMGetInstanceOptions.onMyTeamMembers}</li>
     */
    syncExtraTeamInfo?: boolean;
    /**
     * 默认为false。该参数有两个作用：
     * 1. 初始化阶段是否同步会话未读数
     * 2. 一个端设置未读数时，会话在其它端也标记为已读
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onsessions} 初始化阶段同步会话</li>
     * <li>{@link SessionInterface.setCurrSession} 设置当前会话</li>
     * <li>{@link SessionInterface.resetAllSessionUnread} 设置所有会话未读数</li>
     * <li>{@link SessionInterface.resetSessionsUnread} 批量设置会话未读数</li>
     * <li>{@link SessionInterface.resetSessionUnread} 设置会话未读数</li>
     * <li>{@link SessionInterface.resetSuperTeamSessionsUnread} 设置超级群未读数</li>
     * </ul>
     *
     */
    syncSessionUnread?: boolean;
    /**
     * 是否在初始化时同步云端的置顶会话信息，默认 false。置顶会话信息通过 onStickTopSessions 传给用户，并附带在会话的 isTop 属性中
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link SessionInterface.addStickTopSession} 新增置顶会话</li>
     * <li>{@link SessionInterface.deleteStickTopSession} 删除置顶会话</li>
     * <li>{@link NIMGetInstanceOptions.onStickTopSessions} 同步阶段置顶会话回调</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesessions} 多端登录时通过 onupdatesessions 接收会话置顶变动</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E6%8E%92%E5%BA%8F.js" target="_blank">会话排序</a></li>
     * </ul>
     */
    syncStickTopSessions?: boolean;
    /**
     * 是否同步p2p，以及高级群的漫游消息，默认 true。
     *
     * <h4>关联函数</h4>
     * <li>{@link NIMGetInstanceOptions.onroamingmsgs}</h4>
     */
    syncRoamingMsgs?: boolean;
    /**
     * 是否在初始化时同步超大群的漫游消息, 默认 true。
     *
     * <h4>关联函数</h4>
     * <li>{@link NIMGetInstanceOptions.onroamingmsgs}</h4>
     */
    syncSuperTeamRoamingMsgs?: boolean;
    /**
     * 是否在初始化时同步已读回执时间戳, 默认 true。
     *
     * 若设置为true，则初始化阶段回调函数onsessions中，可以根据session.msgReceiptTime查看会话的已读回执时间
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageInterface.sendMsgReceipt}: 发送已读回执</li>
     * <li>{@link NIMGetInstanceOptions.onsessions}: 初始化阶段已读回执</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesessions}: 在线阶段已读回执</li>
     * </ul>
     */
    syncMsgReceipts?: boolean;
    /**
     * 是否在初始化时同步离线广播消息，默认 false。
     *
     * <h4>关联函数</h4>
     * <li>{@link NIMGetInstanceOptions.onbroadcastmsgs}</li>
     */
    syncBroadcastMsgs?: boolean;
    /**
     * 是否同步信令未读消息，默认true
     *
     * 注：9.10.0及以上支持
     */
    syncAvSignal?: boolean;
    /**
     * 私有化配置
     */
    privateConf?: {
        /**
         * 是否开启ABTest，主版本默认是true，稳定版默认是false
         *
         * 注：稳定版本 8.9.111~8.9.1xx 支持，且主干版本 > 9.11.0 支持
         */
        isABTestEnable?: boolean;
        /**
         * 是否开启数据上报，默认是true
         *
         * 注：稳定版本 8.9.111~8.9.1xx 支持，且主干版本 > 9.11.0 支持
         */
        isDataReportEnable?: boolean;
        /**
         * 是否开启融合存储，主版本默认是true，稳定版默认是false
         *
         * 注：稳定版本 8.9.111~8.9.1xx 支持，且主干版本 > 9.11.0 支持
         */
        isMixStoreEnable?: boolean;
        /**
         * 私有化环境参数。默认为 false，即不需要兼容私有化环境登录参数。
         *
         * 如果私有化环境未升级到最新版本，需要设置该变量为 true，否则会导致登录失败。
         */
        loginSDKTypeParamCompat?: boolean;
    };
    /**
     * 是否对日志做额外的处理，诸如日志存储、日志上报等等。
     *
     * 该函数会截获 SDK 日志的参数，供开发者使用。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.logLevel} 日志等级</li>
     * <li>{@link NIMGetInstanceOptions.dbLog} 是否在数据库中记录日志</li>
     * <li>{@link NIMGetInstanceOptions.expire} 数据库中日志过期时间</li>
     * </ul>
     *
     * <h4>示例</h4>
     *
     * ```js
     * const logs = []
     *
     * setInterval(() => {
     *     if (logs.length > 0) {
     *         //每隔2分钟，将logs的内容上传到您的业务服务器
     *         //...
     *
     *         //清空logs
     *         logs = []
     *     }
     * }, 120000)
     *
     * NIM.getInstance({
     *   logFunc: {
     *     log: function (data) {
     *         logs.push(`log: ${data}`)
     *     },
     *     warn: function (data) {
     *         logs.push(`warn: ${data}`)
     *     },
     *     info: function (data) {
     *         logs.push(`info: ${data}`)
     *     },
     *     debug: function (data) {
     *         logs.push(`debug: ${data}`)
     *     },
     *     error: function (data) {
     *         logs.push(`error: ${data}`)
     *     }
     *   }
     * })
     * ```
     */
    logFunc?: (...args: (string | NIMStrAnyObj)[]) => void;
    /**
     * 判定是否需要忽略通知类型的消息。通知类消息主要包括群通知类消息和超级群通知类消息，具体请查看 {@link NIMGetInstanceOptions.onmsg}
     *
     * @notice 该方法接收一个通知消息，并返回一个布尔值。该值默认为 false。
     * - 如果函数返回 false，则这条通知消息会触发 {@link NIMGetInstanceOptions.onmsg} 以及 {@link NIMGetInstanceOptions.onupdatesessions}
     * - 如果函数返回 true，则这条通知消息不会触发上述回调。也不会影响会话的 lastMsg 以及 unread 属性
     *
     * <h4>示例</h4>
     *
     * ```js
     * NIM.getInstance({
     *   shouldIgnoreNotification: function(msg) {
     *     // 假设在你的业务场景下，移除群成员时，不需要设置群最后一条消息
     *     return msg && msg.attach && msg.attach.type !== "removeTeamMembers"
     *   }
     * })
     * ```
     */
    shouldIgnoreNotification?: (notification: NIMMessage) => void;
    /**
     * 判定通知类消息是否计入会话的未读数。通知类消息主要包括群通知类消息和超级群通知类消息，具体请查看 {@link NIMGetInstanceOptions.onmsg}
     *
     * @notice 该方法接收一个通知消息，如果函数结果返回 true，则将该通知消息计入未读数，否则不计入未读数。默认返回false。
     *
     * <h4>示例</h4>
     *
     * ```js
     * NIM.getInstance({
     *   shouldCountNotifyUnread: function(msg) {
     *     // 假设在你的业务场景下，移除群成员时，不需要设置未读数
     *     return msg && msg.attach && msg.attach.type !== "removeTeamMembers"
     *   }
     * })
     * ```
     */
    shouldCountNotifyUnread?: (notification: NIMMessage) => void;
    /**
     * 设置函数-去设置重连退避间隔. 稳定版自 8.9.124+ 支持，主干版本自 9.16.0+ 支持
     *
     * @param delay 原本的重连退避间隔时间. 单位毫秒
     * @returns 返回一个新的重连退避间隔时间. 单位毫秒
     */
    reconnectDelayProvider?: (delay: number) => number;
    /** ========================== connect start ================================= */
    /**
     * SDK 与云信服务端建立长连接的回调。用户可以通过onwillreconnect, onconnect, ondisconnect等回调函数，在界面中提示应用的网络状态。
     *
     * 连接建立后的回调, 会传入一个对象, 包含登录的信息, 有以下字段:
     * - lastLoginDeviceId: 上次登录的设备的设备号
     * - customTag: 客户端自定义tag,登录时多端同步改字段，最大32个字符
     * - connectionId: 本次登录的连接号
     * - ip: 客户端IP
     * - port: 客户端端口
     * - country: 本次登录的国家
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onwillreconnect}</li>
     * <li>{@link NIMGetInstanceOptions.ondisconnect}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/connect/networkHint.js" target="_blank">网络连接提示</a></li>
     * </ul>
     */
    onconnect?: (data: {
        /**
         * 上次登录的设备的设备号
         */
        lastLoginDeviceId: string;
        /**
         * 客户端自定义 tag。最多 32 个字符。
         */
        customTag?: string;
        /**
         * 本次登录的连接号
         */
        connectionId: string;
        /**
         * 本机外网IP 地址
         */
        ip: string;
        /**
         * 端口
         */
        port: string;
        /**
         * 地区
         */
        country?: string;
    }) => void;
    /**
     * SDK 与云信服务端即将重连的回调。用户可以通过onwillreconnect, onconnect, ondisconnect等回调函数，在界面中提示应用的网络状态
     *
     * @notice 该回调如果触发，说明 SDK 已与云信服务端断开长连接。此时需在界面上提示用户：连接已断开, 而且正在重新建立连接。
     *
     * @notice 若 authType 等于 1，则需要再 onwillreconnect 时动态更新 token。如果是异步场景，比如需要等服务器响应，可以返回一个 Promise, SDK 会等待 Promise 完成后再执行重连
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/connect/%E5%8A%A8%E6%80%81token.js" target="_blank">动态token</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/connect/networkHint.js" target="_blank">网络连接提示</a></li>
     * </ul>
     */
    onwillreconnect?: (data: {
        /**
         * 重试次数
         */
        retryCount: number;
        /**
         * 重试间隔
         */
        duration: number;
    }) => void;
    /**
     * SDK 与云信服务端断开长连接的回调。用户可以通过onwillreconnect, onconnect, ondisconnect等回调函数，在界面中提示应用的网络状态
     *
     * - 此时说明 SDK 处于断开状态, 开发者此时应该根据错误码 `code` 提示相应的错误信息, 并且跳转到登录页面
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onwillreconnect}</li>
     * <li>{@link NIMGetInstanceOptions.onconnect}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/connect/networkHint.js" target="_blank">网络连接提示</a></li>
     * </ul>
     *
     * <h4>示例</h4>
     *
     * ```js
     *   // store代指你的应用中存放数据的对象
     *   NIM.getInstance({
     *     ondisconnect: function (res) {
     *      // 根据断开的 code 设置页面提示
     *      // 数字类型的 code 为初次登陆时，服务器返回的状态码
     *      // 字符类型的 code 为登录保持态断开时的状态码
     *     if (typeof res.code === "number") {
     *       if (res.code === 302) {
     *         store.uistate.networkHint = "账号或者密码错误";
     *       } else if (res.code === 403) {
     *         store.uistate.networkHint = "账号禁止登录";
     *       } else if (res.code === 422) {
     *         store.uistate.networkHint = "账号被禁用";
     *       } else if (res.code === 417) {
     *         store.uistate.networkHint = "重复登录, 已经在其它端登录了";
     *       } else {
     *         store.uistate.networkHint = "账号无法登录";
     *       }
     *     } else if (res.code === "kicked") {
     *       if (res.reason === 'samePlatformKick' || res.reason === 'otherPlatformKick') {
     *         store.uistate.networkHint = '当前账户已在其它设备中登录'
     *       } else if (res.reason === 'serverKick') {
     *         store.uistate.networkHint = '当前设备已被服务器踢掉'
     *       } else {
     *         store.uistate.networkHint = '账号已被踢出'
     *       }
     *     } else if (res.code === "allAttemptsFailed") {
     *       store.uistate.networkHint = "无法连接至服务器";
     *     } else if (res.code === "logout") {
     *       store.uistate.networkHint = "当前账户已登出";
     *     } else {
     *       store.uistate.networkHint = "当前账户已登出";
     *     }
     *
     *     redirect("loginPage");
     *     }
     *   })
     * ```
     */
    ondisconnect?: (data: NIMOnDisconnectResultKicked | NIMOnDisconnectResultOffline | NIMOnDisconnectResultOther) => void;
    /**
     * 初始化同步完成的回调。如果开启了 db，应该在同步结束后再开始调用会使用 db 的操作。
     *
     * @note {@link MessageLogInterface.getHistoryMsgs | getHistoryMsgs} 如果在 onsyncdone 之前调用，则其消息的状态可能不准确。因为消息的状态依赖于同步阶段获取的会话已读时间。
     */
    onsyncdone?: () => void;
    /**
     * 初始化阶段发生错误的回调。
     *
     * @notice 这里的“错误”，通常为数据库错误，也有少量情况为连接错误，建议开发者做错误收集。
     */
    onerror?: (data: NIMStrAnyObj) => void;
    /**
     * 多端登录状态变化的回调, 可通过该回调获取登录端列表。以下情况该回调触发：
     *
     * - 登录时其它端在线
     * - 登录后其它端上线或者下线
     *
     */
    onloginportschange?: (datas: NIMOnLoginPortsChangeResult[]) => void;
    /** ========================== connect end ================================= */
    /** ========================== session start ================================= */
    /**
     * 初始化阶段同步的会话列表
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.syncSessionUnread} 同步会话未读数</li>
     * <li>{@link NIMGetInstanceOptions.syncMsgReceipts} 同步会话已读回执时间戳</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%A4%B4%E5%83%8F%E4%B8%8E%E5%90%8D%E7%A7%B0.js" target="_blank">会话头像与名称</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E6%8E%92%E5%BA%8F.js" target="_blank">会话排序</a></li>
     * </ul>
     */
    onsessions?: (datas: NIMSession[]) => void;
    /**
     * @deprecated 本回调已废弃，建议使用 {@link NIMGetInstanceOptions.onupdatesessions | onupdatesessions}
     */
    onupdatesession?: (data: NIMSession) => void;
    /**
     * 在线阶段会话更新时的回调函数。会话更新可能包含lastMsg、已读回执时间、未读数、是否置顶等更新
     *
     * @notice 该回调自 v8.2.0 起引入，以解决高频次回调的问题。
     *
     * 可能会触发 onupdatesessions 的函数情况包括:
     * <ul>
     * <div><span style="display:inline-block;width:120px;text-align:right;">onmsg触发之后:</span> {@link NIMGetInstanceOptions.onmsg | onmsg} </div>
     * <div><span style="display:inline-block;width:120px;text-align:right;">消息已读回执:</span> {@link MessageInterface.sendMsgReceipt | sendMsgReceipt}、{@link MessageInterface.sendTeamMsgReceipt | sendTeamMsgReceipt}</div>
     * <div><span style="display:inline-block;width:120px;text-align:right;">撤回消息:</span> {@link MessageInterface.recallMsg | recallMsg}</div>
     * <div><span style="display:inline-block;width:120px;text-align:right;">清除历史消息:</span> {@link MessageLogInterface.clearServerHistoryMsgsWithSync | clearServerHistoryMsgsWithSync}</div>
     * <div><span style="display:inline-block;width:120px;text-align:right;">删除单向消息:</span> {@link MessageInterface.deleteMsgSelf | deleteMsgSelf}、{@link MessageInterface.deleteMsgSelfBatch | deleteMsgSelfBatch}</div>
     * <div><span style="display:inline-block;width:120px;text-align:right;">置顶会话:</span> {@link SessionInterface.addStickTopSession | addStickTopSession}、{@link SessionInterface.deleteStickTopSession | deleteStickTopSession}</div>
     * <div><span style="display:inline-block;width:120px;text-align:right;">清理会话未读数:</span> {@link SessionInterface.setCurrSession | setCurrSession}、{@link SessionInterface.resetAllSessionUnread | resetAllSessionUnread}、{@link SessionInterface.resetSessionsUnread | resetSessionsUnread}、{@link SessionInterface.resetSessionUnread | resetSessionUnread}、{@link SessionInterface.resetSuperTeamSessionsUnread | resetSuperTeamSessionsUnread}</div>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%A4%B4%E5%83%8F%E4%B8%8E%E5%90%8D%E7%A7%B0.js" target="_blank">会话头像与名称</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E6%8E%92%E5%BA%8F.js" target="_blank">会话排序</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-%E5%8D%95%E8%81%8A.js" target="_blank">已读回执-单聊</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7-%E7%BE%A4.js" target="_blank">已读回执-群</a></li>
     * </ul>
     *
     */
    onupdatesessions?: (datas: NIMSession[]) => void;
    /**
     * 初始化同步阶段接收置顶会话信息
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.syncStickTopSessions} 必须设置为true，才会收到该回调</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesessions}</li>
     * <li>{@link SessionInterface.addStickTopSession}</li>
     * <li>{@link SessionInterface.deleteStickTopSession}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E6%8E%92%E5%BA%8F.js" target="_blank">会话排序</a></li>
     * </ul>
     */
    onStickTopSessions?: (datas: NIMSession[]) => void;
    /**
     * @deprecated 不建议使用
     *
     * 钩子函数-在初始化时同步接收会话仍有更多的漫游消息回调。
     *
     * 注：其中的 session.time 之前的时间里，仍有超过漫游数量限制而未漫游下来的消息。开发者可以进入会话时，通过获取历史消息再拉取消息。
     */
    onSessionsWithMoreRoaming?: (datas: NIMSession[]) => void;
    /** ========================== session end ================================= */
    /** ========================== msg start ================================= */
    /**
     * 初始化阶段接收漫游消息的回调。具体的消息来源可以查看 {@link NIMGetInstanceOptions.onmsg | onmsg} 回调
     *
     * @notice 初始化同步会触发多次这个事件，每个会话触发一次。
     *
     * <ul>
     * <li>离线消息是指暂无客户端接收过的消息</li>
     * <li>漫游消息是指至少一个客户端接收过的消息</li>
     * </ul>
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onmsg}</li>
     * <li>{@link NIMGetInstanceOptions.onofflinemsgs}</li>
     * <li>{@link NIMGetInstanceOptions.autoMarkRead} 收到消息后，是否自动通知服务器已接收。消息已接收后，消息从离线消息变为漫游消息</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%B4%E6%8A%A4.js" target="_blank">会话中消息队列维护</a></li>
     * </ul>
     */
    onroamingmsgs?: (datas: {
        scene: NIMMsgScene;
        msgs: NIMMessage[];
        sessionId: string;
        to: string;
    }) => void;
    /**
     * 初始化阶段接收离线消息的回调。具体的消息来源可以查看 onmsg 回调
     *
     * @notice 初始化同步会触发多次这个事件，每个会话触发一次。
     *
     * <ul>
     * <li>离线消息是指暂无客户端接收过的消息</li>
     * <li>漫游消息是指至少一个客户端接收过的消息</li>
     * </ul>
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onmsg}</li>
     * <li>{@link NIMGetInstanceOptions.onroamingmsgs}</li>
     * <li>{@link NIMGetInstanceOptions.autoMarkRead} 收到消息后，是否自动通知服务器已接收</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%B4%E6%8A%A4.js" target="_blank">会话中消息队列维护</a></li>
     * </ul>
     */
    onofflinemsgs?: (datas: {
        scene: NIMMsgScene;
        msgs: NIMMessage[];
        sessionId: string;
        to: string;
    }) => void;
    /**
     * 多端同步或在线时接收消息的回调。除了各种类型的基础消息外，重发消息、转发消息也会收到 onmsg 回调。
     *
     * 此外，群相关的部分信息，考虑到一般也会在会话中展示，所以也会触发 onmsg 回调。群消息触发 onmsg 时，具体的群信息类型通过 attach.type 字段查看。详情可以查看: <a href="https://doc.yunxin.163.com/messaging/docs/TIxMjk0ODU?platform=web">群通知消息</a>
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageInterface.sendText} 发送文本信息</li>
     * <li>{@link MessageInterface.sendFile} 发送文件信息</li>
     * <li>{@link MessageInterface.sendCustomMsg} 发送自定义信息</li>
     * <li>{@link MessageInterface.sendGeo} 发送地理信息</li>
     * <li>{@link MessageInterface.sendTipMsg} 发送提示信息</li>
     * <li>{@link MessageInterface.resendMsg} 重发信息</li>
     * <li>{@link MessageInterface.forwardMsg} 转发信息</li>
     * </ul>
     *
     * <h4>群通知消息类型</h4>
     * <ul>
     * <li>{@link TeamInterface.updateTeam} 群信息变更</li>
     * <li>{@link TeamInterface.addTeamMembers} 拉人入群(todo: 系统通知里也有这个)</li>
     * <li>{@link TeamInterface.removeTeamMembers} 移除群成员</li>
     * <li>{@link TeamInterface.acceptTeamInvite} 接收群邀请(若拒绝，邀请方接收rejectTeamInvite系统通知)</li>
     * <li>{@link TeamInterface.passTeamApply} 通过入群申请(若拒绝，申请人接收rejectTeamApply系统通知)</li>
     * <li>{@link TeamInterface.addTeamManagers} 添加群管理员</li>
     * <li>{@link TeamInterface.removeTeamManagers} 移除群管理员</li>
     * <li>{@link TeamInterface.leaveTeam} 群成员退群</li>
     * <li>{@link TeamInterface.dismissTeam} 群解散</li>
     * <li>{@link TeamInterface.transferTeam} 群转让</li>
     * <li>{@link TeamInterface.muteTeamAll} 更新群禁言状态</li>
     * <li>{@link TeamInterface.updateMuteStateInTeam } 更新群成员禁言状态</li>
     * </ul>
     *
     * <h4>超级群通知消息类型</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.updateSuperTeam} 群信息变更</li>
     * <li>{@link SuperTeamInterface.addSuperTeamMembers} 拉人入群(todo: 系统通知里也有这个)</li>
     * <li>{@link SuperTeamInterface.removeSuperTeamMembers} 移除群成员</li>
     * <li>{@link SuperTeamInterface.acceptSuperTeamInvite} 接收群邀请(若拒绝，邀请方接收rejectTeamInvite系统通知)</li>
     * <li>{@link SuperTeamInterface.passSuperTeamApply} 通过入群申请(若拒绝，申请人接收rejectTeamApply系统通知)</li>
     * <li>{@link SuperTeamInterface.addSuperTeamManagers} 添加群管理员</li>
     * <li>{@link SuperTeamInterface.removeSuperTeamManagers} 移除群管理员</li>
     * <li>{@link SuperTeamInterface.leaveSuperTeam} 群成员退群</li>
     * <li>{@link SuperTeamInterface.transferSuperTeam} 群转让</li>
     * <li>{@link SuperTeamInterface.updateSuperTeamMute} 更新群禁言状态</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%B4%E6%8A%A4.js" target="_blank">会话中消息队列维护</a></li>
     * </ul>
     */
    onmsg?: (data: NIMMessage) => void;
    /**
     * 初始化阶段接收离线系统通知。在线系统通知通过 onsysmsg 接收。
     *
     * 系统通知分为内置系统通知，以及自定义系统通知。自定义系统通知请参考 {@link SystemMessageInterface.sendCustomSysMsg}
     *
     * 内置系统通知主要包括用户关系、以及群组两大类型。详细系统通知类型请参考: <a href="https://doc.yunxin.163.com/messaging/docs/zA0ODM2OTI?platform=web#%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B">系统通知类型</a>
     *
     * 会触发系统消息的函数列表，请参考 {@link NIMGetInstanceOptions.onsysmsg | onsysmsg}
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onsysmsg}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/sysmsg/%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5.js" target="_blank">系统通知</a></li>
     * </ul>
     */
    onofflinesysmsgs?: (datas: NIMSystemMessage[]) => void;
    /**
     * 初始化时同步接收漫游系统通知。注意，漫游系统消息仅包含 deleteMsg (recallMsg引发的) 类型的系统消息
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onsysmsg}</li>
     * <li>{@link NIMGetInstanceOptions.onofflinesysmsgs}</li>
     * <li>{@link MessageInterface.recallMsg} 撤回消息</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/sysmsg/%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5.js" target="_blank">系统通知</a></li>
     * </ul>
     */
    onroamingsysmsgs?: (datas: NIMSystemMessage[]) => void;
    /**
     * 多端登录时，接收到删除本地消息的回调函数
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageInterface.deleteMsgSelf}</li>
     * <li>{@link MessageInterface.deleteMsgSelfBatch}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/%E5%8D%95%E5%90%91%E5%88%A0%E9%99%A4%E6%B6%88%E6%81%AF.js" target="_blank">单向删除消息</a></li>
     * </ul>
     *
     */
    onDeleteMsgSelf?: (data: {
        /**
         * 消息场景：
         *
         * <ul><li>p2p：单聊场景</li><li>team：群聊场景</li><li>superteam：超大群场景</li></ul>
         */
        scene: 'p2p' | 'team' | 'superTeam';
        /**
         * 消息发送方, 帐号
         */
        from: string;
        /**
         * 消息接收方, 帐号或群id
         */
        to: string;
        /**
         * 时间戳
         */
        time: number;
        /**
         * 发送方信息更新时间
         */
        /**
         * 端测生成的消息id, 可作为消息唯一主键使用。
         */
        idClient: string;
        /**
         * 服务器用于区分消息用的ID, 用于获取历史消息和获取包含关键词的历史消息。
         */
        idServer: string;
        /**
         * 扩展字段
         *
         * 注：推荐传入 JSON 序列化的字符串
         */
        custom?: string;
        /**
         * 消息删除的时间
         */
        deletedTime: number;
    }) => void;
    /**
     * 离线广播消息到达事件的回调。用户可通过该回调在初始化的同步阶段接收单条或批量接收多条离线广播消息。
     *
     * <h4>关联函数</h4>
     * <ul>
     * {@link NIMGetInstanceOptions.syncBroadcastMsgs}</li>
     * </ul>
     *
     * @notice 广播消息仅支持<a href="https://doc.yunxin.163.com/messaging/docs/Dg1NDYxNTM?platform=server" target="_blank">通过服务端 API 发送</a>。
     */
    onbroadcastmsgs?: (datas: NIMBroadcastMessage[]) => void;
    /**
     * 在线广播消息到达事件的回调。用户可通过该回调接收在线广播消息。
     *
     * @notice 广播消息仅支持<a href="https://doc.yunxin.163.com/messaging/docs/Dg1NDYxNTM?platform=server" target="_blank">通过服务端 API 发送</a>。
     */
    onbroadcastmsg?: (data: NIMBroadcastMessage) => void;
    /**
     * 接收到其它用户消息已读回执的通知。注意，发送群消息时需要设置needMsgReceipt = true，否则无法收到 onMsgReceipts 回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageInterface.sendTeamMsgReceipt} 发送群消息已读回执</li>
     * <li>{@link MessageInterface.getTeamMsgReads} 获取多条群消息已读数</li>
     * <li>{@link MessageInterface.getTeamMsgReadAccounts} 获取单条群消息已读账户</li>
     * </ul>
     */
    onMsgReceipts?: (datas: NIMTeamMsgReceipt[] | NIMP2PMsgReceipt[]) => void;
    /**
     * @deprecated 已废弃。推荐开发者调用 {@link NIMGetInstanceOptions.onMsgReceipts}
     */
    onTeamMsgReceipt?: (data: {
        /**
         * data.teamMsgReceipts:
         * <ul>
         * <li>teamId: 消息所属群id</li>
         * <li>idServer: 消息的idServer</li>
         * <li>idClient: 消息的idClient</li>
         * <li>read: 当前已标记 receipt 的人数</li>
         * <li>unread: 当前未标记 receipt 的人数</li>
         * <li>account: 当前标记 receipt 者的账号 account ID</li>
         * </ul>
         */
        teamMsgReceipts: {
            teamId: string;
            /**
             * 消息的 idServer
             */
            idServer: string;
            /**
             * 消息的 idServer
             */
            idClient: string;
            /**
             * 当前已标记 receipt 的人数
             */
            read: number;
            /**
             * 当前未标记 receipt 的人数
             */
            unread: number;
            /**
             * 当前标记 receipt 者的账号 account ID
             */
            account: string;
        }[];
    }) => void;
    /** ========================== msg end ================================= */
    /** ========================== sysmsg start ================================= */
    /**
     * 在线时接收系统通知。离线阶段的系统通知通过 onofflinesysmsgs 接收。
     *
     * 系统通知分为内置系统通知，以及自定义系统通知。自定义系统通知请参考 {@link SystemMessageInterface.sendCustomSysMsg}
     *
     * 内置系统通知主要包括用户关系、以及群组两大类型。详细系统通知类型请参考: <a href="https://doc.yunxin.163.com/messaging/docs/zA0ODM2OTI?platform=web#%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B">系统通知类型</a>
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onofflinesysmsgs} 初始化阶段，接收离线系统通知</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesysmsg} 系统通知更新通知</li>
     * <li>{@link NIMGetInstanceOptions.onsysmsgunread} 初始化阶段，获取系统通知未读数</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesysmsgunread} 在线接收系统通知未读数更新</li>
     * </ul>
     *
     * <h4>群相关系统通知关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.addTeamMembers} 邀请入群(todo: onmsg中也有这个)</li>
     * <li>{@link TeamInterface.rejectTeamInvite} 拒绝入群邀请</li>
     * <li>{@link TeamInterface.applyTeam} 申请入群</li>
     * <li>{@link TeamInterface.rejectTeamApply} 拒绝入群申请</li>
     * </ul>
     *
     * <h4>超级群相关系统通知关联函数</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.addSuperTeamMembers} 邀请入群</li>
     * <li>{@link SuperTeamInterface.rejectSuperTeamInvite} 拒绝入群邀请</li>
     * <li>{@link SuperTeamInterface.applySuperTeam} 申请入群</li>
     * <li>{@link SuperTeamInterface.rejectSuperTeamApply} 拒绝入群申请</li>
     * </ul>
     *
     * <h4>好友相关系统通知关联函数</h4>
     * <ul>
     * <li>{@link FriendInterface.addFriend} 添加好友</li>
     * <li>{@link FriendInterface.applyFriend} 申请好友</li>
     * <li>{@link FriendInterface.passFriendApply} 通过好友申请</li>
     * <li>{@link FriendInterface.rejectFriendApply} 拒绝好友申请</li>
     * <li>{@link FriendInterface.deleteFriend} 删除好友</li>
     * </ul>
     *
     * <h4>其它关联函数</h4>
     * <ul>
     * <li>{@link MessageInterface.recallMsg} 撤回消息</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/sysmsg/%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5.js" target="_blank">系统通知</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E7%94%A8%E6%88%B7%E8%B5%84%E6%96%99%E4%B8%8E%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB.js" target="_blank">用户资料与好友关系</a></li>
     * </ul>
     */
    onsysmsg?: (data: NIMSystemMessage) => void;
    /**
     * 在线接收系统通知更新的回调。在通过或者拒绝好友申请、接收或者拒绝入群申请、通过或者拒绝入群邀请时触发。发送这些动作后：
     * <ul>
     * <li>发送者的设备触发: {@link NIMGetInstanceOptions.onupdatesysmsg | onupdatesysmsg} </li>
     * <li>多端登录设备触发: {@link NIMGetInstanceOptions.onsyncfriendaction | onsyncfriendaction} </li>
     * <li>接收者的设备触发: {@link NIMGetInstanceOptions.onsysmsg | onsysmsg}、{@link NIMGetInstanceOptions.onupdatesysmsgunread | onupdatesysmsgunread} </li>
     * </ul>
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onsysmsg}</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesysmsgunread}</li>
     * <li>{@link NIMGetInstanceOptions.onsyncfriendaction}</li>
     * </ul>
     *
     * <h4>好友关联函数</h4>
     * <ul>
     * <li>{@link FriendInterface.passFriendApply}</li>
     * <li>{@link FriendInterface.rejectFriendApply}</li>
     * </ul>
     *
     * <h4>群关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.passTeamApply}</li>
     * <li>{@link TeamInterface.rejectTeamApply}</li>
     * <li>{@link TeamInterface.acceptTeamInvite}</li>
     * <li>{@link TeamInterface.rejectTeamInvite}</li>
     * </ul>
     *
     * <h4>超级群关联函数</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.passSuperTeamApply}</li>
     * <li>{@link SuperTeamInterface.rejectSuperTeamApply}</li>
     * <li>{@link SuperTeamInterface.acceptSuperTeamInvite}</li>
     * <li>{@link SuperTeamInterface.rejectSuperTeamInvite}</li>
     * </ul>
     */
    onupdatesysmsg?: (data: NIMSystemMessage) => void;
    /**
     * 在线自定义系统通知的回调。用户在线时通过该回调接收系统通知。
     *
     * SDK 仅透传自定义系统通知，不负责解析和存储，也不管理其未读数，通知内容由第三方 APP 自由扩展。
     * 开发者可以根据其业务逻辑自定义一些事件状态的通知，来实现各种业务场景。例如实现单聊场景中的对方“正在输入”的功能。
     *
     * 请参考文档：https://doc.yunxin.163.com/messaging/docs/zQxOTIwMDc?platform=web 查看自定义系统通知的详细用法
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onofflinecustomsysmsgs} 初始化阶段接收离线自定义系统通知</li>
     * <li>{@link SystemMessageInterface.sendCustomSysMsg} 发送自定义系统通知</li>
     * </ul>
     *
     * @notice 自定义系统通知不存本地数据库，会直接回调透传给开发者。
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/message/p2p%E6%AD%A3%E5%9C%A8%E8%BE%93%E5%85%A5.js" target="_blank">p2p正在输入提示</a></li>
     * </ul>
     */
    oncustomsysmsg?: (data: NIMSystemMessage) => void;
    /**
     * 初始化阶段同步离线自定义系统通知
     *
     * SDK 仅透传自定义系统通知，不负责解析和存储，也不管理其未读数，通知内容由第三方 APP 自由扩展。
     * 开发者可以根据其业务逻辑自定义一些事件状态的通知，来实现各种业务场景。例如实现单聊场景中的对方“正在输入”的功能。
     *
     * 请参考文档：https://doc.yunxin.163.com/messaging/docs/zQxOTIwMDc?platform=web 查看自定义系统通知的详细用法
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.oncustomsysmsg} 在线自定义系统通知回调</li>
     * <li>{@link SystemMessageInterface.sendCustomSysMsg} 发送自定义系统通知</li>
     * </ul>
     *
     * @note 自定义系统通知不存本地数据库，会直接回调透传给开发者。
     */
    onofflinecustomsysmsgs?: (datas: NIMSystemMessage[]) => void;
    /**
     *
     * 初始化阶段，获取系统消息未读数。注意，该回调仅在db = true时有意义。
     *
     * 初始化阶段，SDK会接收离线系统消息 ({@link NIMGetInstanceOptions.onofflinesysmsgs | onofflinesysmsgs})，以及漫游系统消息 ({@link NIMGetInstanceOptions.onroamingsysmsgs | onroamingsysmsgs})，然后和db中保存的系统消息合并后，计算系统消息的未读数
     *
     * 注意未读数结果中，以下字段为:
     * <ul>
     * <li>total = friend + msg + team + superTeam</li>
     * <li>msg = deleteMsg</li>
     * <li>friend = applyFriend + passFriendApply + rejectFriendApply + deleteFriend</li>
     * <li>team = applyTeam + rejectTeamApply + teamInvite + rejectTeamInvite</li>
     * <li>superTeam = applySuperTeam + rejectSuperTeamApply + superTeamInvite + rejectSuperTeamInvite</li>
     * </ul>
     *
     * 会触发系统通知的函数列表请查看 {@link NIMGetInstanceOptions.onsysmsg | onsysmsg}
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.db} 设置是否使用db</li>
     * <li>{@link NIMGetInstanceOptions.onofflinesysmsgs} 初始化阶段同步离线系统消息</li>
     * <li>{@link NIMGetInstanceOptions.onroamingsysmsgs} 初始化阶段同步漫游系统消息</li>
     * <li>{@link NIMGetInstanceOptions.onupdatesysmsgunread} 在线阶段系统通知未读数更新</li>
     * <li>{@link SystemMessageInterface.markSysMsgRead} 标记db中系统通知已读</li>
     * </ul>
     *
     */
    onsysmsgunread?: (data: NIMSystemMessageUnreadInfo) => void;
    /**
     *
     * 在线时接收系统通知未读数的更新。注意，该回调仅在db = true时有意义。
     *
     * 在线阶段，SDK接收到系统通知后更新未读数。或者，SDK调用本地系统通知已读后，收到系统通知未读数更新回调
     *
     * 注意未读数结果中，以下字段为:
     * <ul>
     * <li>total = friend + msg + team + superTeam</li>
     * <li>msg = deleteMsg</li>
     * <li>friend = applyFriend + passFriendApply + rejectFriendApply + deleteFriend</li>
     * <li>team = applyTeam + rejectTeamApply + teamInvite + rejectTeamInvite</li>
     * <li>superTeam = applySuperTeam + rejectSuperTeamApply + superTeamInvite + rejectSuperTeamInvite</li>
     * </ul>
     *
     * 会触发系统通知的函数列表请查看 {@link NIMGetInstanceOptions.onsysmsg | onsysmsg}
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.db} 设置是否使用db</li>
     * <li>{@link SystemMessageInterface.markSysMsgRead} 标记db中系统通知已读</li>
     * </ul>
     */
    onupdatesysmsgunread?: (data: NIMSystemMessageUnreadInfo) => void;
    /** ========================== sysmsg end ================================= */
    /** ========================== event start ================================= */
    /**
     * 在初始化阶段，或者在线时，接收订阅事件。
     *
     * 接收订阅事件之前，需要调用 {@link EventInterface.subscribeEvent | subscribeEvent} 订阅事件。
     *
     * 订阅事件时，可以设置有效时间，在有效时间内重新登录，无需重新调用 {@link EventInterface.subscribeEvent | subscribeEvent}
     *
     * <h4>订阅事件类型</h4>
     * 1. 在线状态订阅, 主要用于监听好友的在线状态。初始化阶段，只有订阅监听的账户在线时，才会收到在线订阅事件
     * <ul>
     * <li>type = 1, value = 1: 用户在线</li>
     * <li>type = 1, value = 2: 用户登出</li>
     * <li>type = 1, value = 3: 用户断开连接</li>
     * </ul>
     * 2. 用户自定义事件。通过 {@link EventInterface.publishEvent | publishEvent} 发布
     * 用户自定义的订阅事件必须为 type = 1, value >= 10000
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link EventInterface.subscribeEvent}</li>
     * <li>{@link EventInterface.publishEvent}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/event/%E7%94%A8%E6%88%B7%E4%B8%8A%E7%BA%BF%E4%B8%8B%E7%BA%BF.js" target="_blank">用户在线状态维护</a></li>
     * </ul>
     */
    onpushevents?: (result: {
        msgEvents: NIMPushEventInfo[];
    }) => void;
    /** ========================== event end ================================= */
    /** ========================== msgExtend start ================================= */
    /**
     * 对消息添加快捷评论后，消息的发送者，以及快捷评论的多端登录设备，会收到 onQuickComment 回调函数
     *
     * 快捷评论只能够发送整数类型的字段。常用快捷评论给消息添加表情类的回复。比如1代表鲜花，2代表开心，等等。
     *
     * 同一个用户发送多次同一类型的快捷评论时，先发送的评论会被后续的发送覆盖
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageExtendInterface.addQuickComment}</li>
     * <li>{@link MessageExtendInterface.deleteQuickComment}</li>
     * <li>{@link NIMGetInstanceOptions.onDeleteQuickComment}</li>
     * </ul>
     *
     * <h4>示例</h4>
     *
     * ```js
     * // key: sessionId
     * // value.msgs: 消息列表
     * // value.msgs[idx].quickComments: 评论列表
     * const sessions = {}
     *
     * function getSessionId(msg) {
     *   if (msg.scene !== 'p2p') {
     *     return `${msg.scene}-${msg.to}`
     *   } else if (msg.from === nim.account) {
     *     return `p2p-${msg.to}`
     *   } else {
     *     return `p2p-${msg.from}`
     *   }
     * }
     *
     * nim = NIM.getInstance({
     *   //收到了新的评论，将评论附加到消息的快捷评论队列中
     *   onQuickComment: function(msg, comment) {
     *     const sessionId = getSessionId(msg)
     *     const session = sessions[sessionId]
     *     if (session) {
     *       for (let _msg of session.msgs) {
     *         if (_msg.idClient === msg.idClient) {
     *           // 找到了被评论的消息
     *           _msg.quickComments = _msg.quickComments || []
     *
     *           // 先剔除同一账号类型相同的快捷评论
     *           for (let i = _msg.quickComments.length - 1; i >= 0; i--) {
     *             if (_msg.quickComments[i].from === comment.from && _msg.quickComments[i].body === comment.body) {
     *               _msg.quickComments.splice(i, 1)
     *               break
     *             }
     *           }
     *
     *           _msg.quickComments.push(comment)
     *         }
     *       }
     *     }
     *   }
     * })
     * ```
     */
    onQuickComment?: (msg: {
        /**
         * 消息场景：
         *
         * <ul><li>p2p：单聊场景</li><li>team：群聊场景</li><li>superteam：超大群场景</li></ul>
         */
        scene: 'p2p' | 'team' | 'superTeam';
        /**
         * 消息发送方, 帐号
         */
        from: string;
        /**
         * 消息接收方, 帐号或群id
         */
        to: string;
        /**
         * 时间戳
         */
        time: number;
        /**
         * 发送方信息更新时间
         */
        /**
         * 端测生成的消息id, 可作为消息唯一主键使用。
         */
        idClient: string;
        /**
         * 服务器用于区分消息用的ID, 用于获取历史消息和获取包含关键词的历史消息。
         */
        idServer: string;
    }, comment: {
        /**
         * 快捷评论内容
         */
        body: number;
        /**
         * 扩展内容
         */
        custom?: string;
        /**
         * 该评论的发送方的 account ID
         */
        from: string;
        /**
         * 评论的发送时间。
         */
        time: number;
    }) => void;
    /**
     * 删除快捷评论时，消息的发送者，以及快捷评论发送者的多端登录账户会收到 onDeleteQuickComment 回调函数
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageExtendInterface.addQuickComment}</li>
     * <li>{@link MessageExtendInterface.deleteQuickComment}</li>
     * <li>{@link NIMGetInstanceOptions.onQuickComment}</li>
     * </ul>
     *
     * <h4>示例</h4>
     *
     * ```js
     * // key: sessionId
     * // value.msgs: 消息列表
     * // value.msgs[idx].quickComments: 评论列表
     * const sessions = {}
     *
     * function getSessionId(msg) {
     *   if (msg.scene !== 'p2p') {
     *     return `${msg.scene}-${msg.to}`
     *   } else if (msg.from === nim.account) {
     *     return `p2p-${msg.to}`
     *   } else {
     *     return `p2p-${msg.from}`
     *   }
     * }
     *
     *
     * nim = NIM.getInstance({
     *   // 收到了删除评论的通知，从快捷评论队列中移除评论
     *   onDeleteQuickComment: function(msg, comment) {
     *     const sessionId = getSessionId(msg)
     *     const session = sessions[sessionId]
     *     if (session) {
     *       for (let _msg of session.msgs) {
     *         if (_msg.idClient === msg.idClient) {
     *           // 找到了被评论的消息
     *           _msg.quickComments = _msg.quickComments || []
     *
     *           // 剔除同一账号类型相同的快捷评论
     *           for (let i = _msg.quickComments.length - 1; i >= 0; i--) {
     *             if (_msg.quickComments[i].from === comment.from && _msg.quickComments[i].body === comment.body) {
     *               _msg.quickComments.splice(i, 1)
     *               break
     *             }
     *           }
     *         }
     *       }
     *     }
     *   }
     * })
     * ```
     */
    onDeleteQuickComment?: (data: {
        /**
         * 消息场景：
         *
         * <ul><li>p2p：单聊场景</li><li>team：群聊场景</li><li>superteam：超大群场景</li></ul>
         */
        scene: 'p2p' | 'team' | 'superTeam';
        /**
         * 消息发送方, 帐号
         */
        from: string;
        /**
         * 消息接收方, 帐号或群id
         */
        to: string;
        /**
         * 时间戳
         */
        time: number;
        /**
         * 发送方信息更新时间
         */
        /**
         * 端测生成的消息id, 可作为消息唯一主键使用。
         */
        idClient: string;
        /**
         * 服务器用于区分消息用的ID, 用于获取历史消息和获取包含关键词的历史消息。
         */
        idServer: string;
    }, comment: {
        /**
         * 快捷评论内容
         */
        body: number;
        /**
         * 扩展内容
         */
        custom?: string;
        /**
         * 该评论的发送方的 account ID
         */
        from: string;
        /**
         * 评论的发送时间。
         */
        time: number;
    }) => void;
    /**
     * 新增、更新、删除 一条消息的PIN标记时，会触发多端登录设备的 onPinMsgChange 回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link MessageExtendInterface.addMsgPin}</li>
     * <li>{@link MessageExtendInterface.deleteMsgPin}</li>
     * <li>{@link MessageExtendInterface.updateMsgPin}</li>
     * </ul>
     *
     * <h4>示例</h4>
     *
     * ```js
     * // key: sessionId
     * // value.msgs: 会话中消息列表
     * // value.msgs[idx].pinInfo: 如果有pinInfo，说明该消息被收藏
     * const sessions = {}
     *
     * // 找到会话列表中被PIN的消息
     * function getMsgInSessions(msg) {
     *   const sessionId = getSessionId(msg)
     *   const session = sessions[sessionId]
     *   if (session) {
     *     const msgs = session.msgs || []
     *     for (let _msg of msgs) {
     *       if (msg.idClient === _msg.idClient) {
     *         return _msg
     *       }
     *     }
     *   }
     * }
     *
     * function getSessionId(msg) {
     *   if (msg.scene !== 'p2p') {
     *     return `${msg.scene}-${msg.to}`
     *   } else if (msg.from === nim.account) {
     *     return `p2p-${msg.to}`
     *   } else {
     *     return `p2p-${msg.from}`
     *   }
     * }
     *
     * nim = NIM.getInstance({
     *   onPinMsgChange: function (data, action) {
     *     const _msg = getMsgInSessions(data.msg)
     *     if (action === 'add' || action === 'update') {
     *       _msg.pinInfo = data.pinTag
     *     } else {
     *       _msg.pinInfo = undefined
     *     }
     *   }
     * })
     * ```
     */
    onPinMsgChange?: (data: {
        /**
         * 被 pin 标记的消息的基础结构
         */
        msg: NIMMsgPinInfo;
        pinTag: {
            /**
             * pin 标记的扩展字段
             */
            pinCustom?: string;
            /**
             * pin 标记的操作者
             */
            pinFrom: string;
            createTime: number;
            updateTime: number;
        };
    }, action: 'add' | 'update' | 'delete') => void;
    /** ========================== msgExtend end ================================= */
    /** ========================== msgLog start ================================= */
    /**
     * 多端同步或初始化同步时，接收函数 {@link MessageLogInterface.clearServerHistoryMsgsWithSync} 调用后的回调函数。
     *
     * 无论用户是否注册该回调，SDK都会在收到多端同步删除云端历史时，清空本地数据库中对应会话的数据。
     *
     * 用户收到该事件后，应该将会话中，时间早于该事件时间的消息清空
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E5%88%A0%E9%99%A4%E4%BC%9A%E8%AF%9D.js" target="_blank">删除会话</a></li>
     * </ul>
     */
    onClearServerHistoryMsgs?: (dataArr: {
        /**
         * 会话的 ID
         */
        sessionId: string;
        /**
         * 删除时间
         */
        time: number;
        /**
         * 自定义扩展字段
         */
        ext: string | undefined;
    }[]) => void;
    /** ========================== msgLog end ================================= */
    /** ========================== cloudSession start ================================= */
    /**
     * 调用 updateServerSession 后，多端登录设备收到该回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link CloudSessionInterface.updateServerSession}</li>
     * </ul>
     */
    onSyncUpdateServerSession?: (data: NIMCloudSession) => void;
    /** ========================== cloudSession end ================================= */
    /** ========================== frined/user/relation start ================================= */
    /**
     * 初始化阶段返回黑名单列表。注意，黑名单是单向的。当前用户的黑名单，是指其它用户无法对当前用户发送消息。反之并不受影响。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.syncRelations} 初始化阶段是否同步黑名单、静音名单</li>
     * <li>{@link UserInterface.addToBlacklist} 添加用户至黑名单列表</li>
     * <li>{@link UserInterface.removeFromBlacklist} 从黑名单列表中移除用户</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E9%BB%91%E5%90%8D%E5%8D%95.js" target="_blank">黑名单</a></li>
     * </ul>
     */
    onblacklist?: (datas: {
        account: string;
        createTime: number;
        updateTime: number;
    }[]) => void;
    /**
     * 多端登录时接收“拉黑/移出黑名单事件”的回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link UserInterface.addToBlacklist} 添加用户至黑名单列表</li>
     * <li>{@link UserInterface.removeFromBlacklist} 从黑名单列表中移除用户</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E9%BB%91%E5%90%8D%E5%8D%95.js" target="_blank">黑名单</a></li>
     * </ul>
     */
    onsyncmarkinblacklist?: (data: {
        /**
         * 被操作者账号 ID
         */
        account: string;
        /**
         * 是否加入名单(黑名单或者静音列表)
         *
         * true 代表某人被加入名单，false 代表某人被移出名单
         */
        isAdd: boolean;
        /**
         * 该操作记录的详情
         */
        record: {
            /**
             * 被操作者账号 ID
             */
            account: string;
            /**
             * 更新时间戳
             */
            updateTime: number;
        };
    }) => void;
    /**
     * 初始化阶段返回静音列表。注意，和黑名单一样，静音名单为单向的。静音名单主要的作用是设置会话免打扰：
     * - 静音列表中用户发送消息时，不会有离线消息推送
     * - 应用层可以根据静音列表，决定是否渲染消息未读数通知
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.syncRelations} 初始化阶段是否同步黑名单、静音名单</li>
     * <li>{@link UserInterface.addToMutelist} 添加用户至静音列表</li>
     * <li>{@link UserInterface.removeFromMutelist} 从静音列表中移除用户</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%85%8D%E6%89%93%E6%89%B0.js" target="_blank">会话免打扰</a></li>
     * </ul>
     */
    onmutelist?: (datas: {
        account: string;
        createTime: number;
        updateTime: number;
    }[]) => void;
    /**
     * 多端登录时接收“拉黑/移出静音列表”的回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link UserInterface.addToMutelist} 添加用户至静音列表</li>
     * <li>{@link UserInterface.removeFromMutelist} 从静音列表中移除用户</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%85%8D%E6%89%93%E6%89%B0.js" target="_blank">会话免打扰</a></li>
     * </ul>
     */
    onsyncmarkinmutelist?: (data: {
        /**
         * 被操作者账号 ID
         */
        account: string;
        /**
         * 是否加入名单(黑名单或者静音列表)
         *
         * true 代表某人被加入名单，false 代表某人被移出名单
         */
        isAdd: boolean;
        /**
         * 该操作记录的详情
         */
        record: {
            /**
             * 被操作者账号 ID
             */
            account: string;
            /**
             * 更新时间戳
             */
            updateTime: number;
        };
    }) => void;
    /**
     * 初始化阶段同步好友列表。若没有好友：
     * - db开启时，会触发该回调，传入空数组
     * - db关闭时，不会触发该回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.syncFriends} 初始化阶段是否同步好友列表</li>
     * <li>{@link FriendInterface.addFriend} 添加好友(无需认证)</li>
     * <li>{@link FriendInterface.applyFriend} 申请好友</li>
     * <li>{@link FriendInterface.passFriendApply} 申请好友通过</li>
     * <li>{@link FriendInterface.rejectFriendApply} 申请好友拒绝</li>
     * <li>{@link FriendInterface.deleteFriend} 删除好友</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E7%94%A8%E6%88%B7%E8%B5%84%E6%96%99%E4%B8%8E%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB.js" target="_blank">用户资料与好友关系</a></li>
     * </ul>
     */
    onfriends?: (datas: NIMFriendProfile[]) => void;
    /**
     * 多端登录时接收好友动作的回调。好友动作包括添加好友、好友申请、通过好友申请、拒绝好友申请、删除好友和更新好友备注。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link FriendInterface.addFriend}</li>
     * <li>{@link FriendInterface.applyFriend}</li>
     * <li>{@link FriendInterface.passFriendApply}</li>
     * <li>{@link FriendInterface.rejectFriendApply}</li>
     * <li>{@link FriendInterface.deleteFriend}</li>
     * <li>{@link FriendInterface.updateFriend}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E7%94%A8%E6%88%B7%E8%B5%84%E6%96%99%E4%B8%8E%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB.js" target="_blank">用户资料与好友关系</a></li>
     * </ul>
     */
    onsyncfriendaction?: (data: {
        /**
         * 好友动作类型
         *
         * <ul>
         * <li>addFriend 添加好友</li>
         * <li>applyFriend 好友申请</li>
         * <li>passFriendApply 通过好友申请</li>
         * <li>rejectFriendApply 拒绝好友申请</li>
         * <li>deleteFriend 删除好友</li>
         * <li>updateFriend 更新好友备注</li>
         * </ul>
         */
        type: 'addFriend' | 'applyFriend' | 'passFriendApply' | 'rejectFriendApply' | 'deleteFriend' | 'updateFriend';
        /**
         * 好友信息。当type为下列类型时存在:
         * - addFriend
         * - passFriendApply
         * - updateFriend
         */
        friend?: NIMFriendProfile;
        /**
         * 账号信息，当 type 为下列类型时存在:
         * - addFriend
         * - applyFriend
         * - passFriendApply
         * - rejectFriendApply
         * - deleteFriend
         */
        account?: string;
    }) => void;
    /**
     * 初始化阶段同步自己的用户名片的回调。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link UserInterface.updateMyInfo}</li>
     * <li>{@link NIMGetInstanceOptions.onupdatemyinfo}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99.js" target="_blank">个人资料</a></li>
     * </ul>
     */
    onmyinfo?: (data: NIMUserNameCard) => void;
    /**
     * 调用 updateMyInfo 时，多端登录设备会收到此回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link UserInterface.updateMyInfo}</li>
     * <li>{@link NIMGetInstanceOptions.onmyinfo}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99.js" target="_blank">个人资料</a></li>
     * </ul>
     */
    onupdatemyinfo?: (data: NIMUserNameCard) => void;
    /**
     * 初始化阶段接收好友的用户名片的回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.syncFriendUsers}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%A4%B4%E5%83%8F%E4%B8%8E%E5%90%8D%E7%A7%B0.js" target="_blank">会话头像与名称</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E7%94%A8%E6%88%B7%E8%B5%84%E6%96%99%E4%B8%8E%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB.js" target="_blank">用户资料与好友关系</a></li>
     * </ul>
     *
     */
    onusers?: (datas: NIMUserNameCard[]) => void;
    /**
     * 在线阶段接收消息后，发线聊天对象有用户名片上的信息更新时触发回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link NIMGetInstanceOptions.onmsg}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%A4%B4%E5%83%8F%E4%B8%8E%E5%90%8D%E7%A7%B0.js" target="_blank">会话头像与名称</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/user/%E7%94%A8%E6%88%B7%E8%B5%84%E6%96%99%E4%B8%8E%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB.js" target="_blank">用户资料与好友关系</a></li>
     * </ul>
     */
    onupdateuser?: (data: NIMUserNameCard) => void;
    /** ========================== frined/user/relation end ================================= */
    /** ========================== superTeam start ================================= */
    /**
     * 初始化时同步超级群列表的回调
     *
     * <h4>示例</h4>
     *
     * ```js
     * const superTeamById = {}
     *
     * nim = NIM.getInstance({
     *   syncSuperTeams: true
     *   onSuperTeams: function (teamArr) {
     *     for (let team of teamArr) {
     *       superTeamById[team.teamId] = team
     *     }
     *   }
     * })
     * ```
     */
    onSuperTeams?: (datas: NIMSuperTeam[]) => void;
    /**
     * 在线阶段，群主收到超级群创建的通知(超级群只能够通过服务器接口创建)
     */
    onSyncCreateSuperTeam?: (datas: NIMSuperTeam[]) => void;
    /**
     * 钩子函数-在线或多端同步时接收更新超级群的通知的回调。
     */
    /**
     * 超级群资料更新时，或者更新群全体禁言状态时，群内在线成员都会收到该回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.updateSuperTeam}</li>
     * <li>{@link SuperTeamInterface.updateSuperTeamMute}</li>
     * <li>{@link SuperTeamInterface.updateInfoInSuperTeam}</li>
     * <li>{@link SuperTeamInterface.updateNickInSuperTeam}</li>
     * </ul>
     *
     */
    onUpdateSuperTeam?: (data: Pick<NIMSuperTeam, 'announcement' | 'avatar' | 'custom' | 'intro' | 'name' | 'teamId' | 'updateTime'>) => void;
    /**
     * 群解散时，群内所有成员收到 onDismissSuperTeam 的回调。群解散接口只能够通过服务器API调用
     *
     * <h4>示例</h4>
     *
     * ```js
     * const superTeamById = {}
     *
     * nim = NIM.getInstance({
     *   onDismissSuperTeam: function (data) {
     *     console.log('debug++ onDismissSuperTeam', data)
     *     const teamId = data.teamId
     *     delete superTeamById[teamId]
     *   }
     * })
     * ```
     */
    onDismissSuperTeam?: (data: {
        teamId: string;
    }) => void;
    /**
     * 超级群群主变更时，所有在线群成员都会收到此回调。此方法参数包含群信息，以及新老群主信息
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.transferSuperTeam}</li>
     * </ul>
     */
    onTransferSuperTeam?: (data: {
        /**
         * 转让者的信息
         */
        from: Pick<NIMSuperTeamMember, 'id' | 'type' | 'updateTime'>;
        /**
         * 被转让的目标用户的信息
         */
        to: Pick<NIMSuperTeamMember, 'id' | 'type' | 'updateTime'>;
        team: NIMSuperTeam;
    }) => void;
    /**
     * 在线或多端同步时接收“超级群成员的信息变更”的回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.updateInfoInSuperTeam}</li>
     * <li>{@link SuperTeamInterface.updateNickInSuperTeam}</li>
     * </ul>
     */
    onUpdateSuperTeamMember?: (data: Pick<NIMSuperTeamMember, 'account' | 'custom' | 'id' | 'muteNotiType' | 'muteTeam' | 'nickInTeam' | 'teamId' | 'updateTime'>) => void;
    /**
     * (初始化同步, 在线, 多端同步)收到了当前账户，在各个群内的信息设置。比如当前用户是否为群主、管理员、是否设置了免打扰等等。
     *
     * 注: 自己的超级群成员信息里有字段可以代表对此群的免打扰策略，开发者可自行组合到 session 中。
     */
    onMySuperTeamMembers?: (data: NIMSuperTeamMember[]) => void;
    /**
     * 有成员进入超级群时，包括该成员在内所有在线的客户端，触发该回调函数。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.addSuperTeamMembers} 拉人入群，或者邀请用户入群</li>
     * <li>{@link SuperTeamInterface.acceptSuperTeamInvite} 接受入群邀请</li>
     * <li>{@link SuperTeamInterface.applySuperTeam} 申请入群</li>
     * <li>{@link SuperTeamInterface.passSuperTeamApply} 接受入群申请</li>
     * </ul>
     */
    onAddSuperTeamMembers?: (data: {
        /**
         * 被添加的用户的账号
         */
        account: string[];
        /**
         * 被添加的用户的群成员信息
         */
        members: NIMSuperTeamMember[];
        /**
         * 群的信息
         */
        team: NIMSuperTeam;
    }) => void;
    /**
     * 有成员离开超级群时，包括该成员在内所有在线的客户端，触发该回调函数。
     *
     * @notice 开发者需要判定 data 里 account 是否包含当前 IM 账号（accid）, 来处理当前 IM 账号被踢出群的情况。
     */
    onRemoveSuperTeamMembers?: (data: {
        /**
         * 被添加的用户的 IM 账号(accid)
         */
        account: string[];
        /**
         * 群 ID
         */
        teamId: string;
        /**
         * 群的信息。
         *
         * 注: 已知主动离开群的场景触发的 onRemoveSuperTeamMembers 是不存在 team 信息的。
         */
        team?: NIMSuperTeam;
    }) => void;
    /**
     * 超级群管理成员变更时，在线群成员会收到该回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.addSuperTeamManagers}</li>
     * <li>{@link SuperTeamInterface.removeSuperTeamManagers}</li>
     * </ul>
     */
    onUpdateSuperTeamManagers?: (data: {
        /**
         * 被添加的用户的账号
         */
        account: string[];
        /**
         * 是否为管理员.
         *
         * 若为 false 代表被移出管理员列表.
         */
        isManager: boolean;
        /**
         * 被添加的用户的群成员基础信息
         */
        members: Pick<NIMSuperTeamMember, 'id' | 'type' | 'updateTime'>[];
        /**
         * 群的基础信息
         */
        team: Pick<NIMSuperTeam, 'teamId' | 'memberUpdateTime'>;
    }) => void;
    /**
     * 对指定成员禁言或者解除禁言后，超级群内所有在线成员收到该回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link SuperTeamInterface.updateSuperTeamMembersMute}</li>
     * </ul>
     */
    onUpdateSuperTeamMembersMute?: (data: {
        /**
         * 被添加的用户的账号
         */
        account: string[];
        /**
         * 是否静音.
         *
         * 若为 false 代表被移出静音列表.
         */
        mute: boolean;
        /**
         * 被添加的用户的群成员基础信息
         */
        members: Pick<NIMSuperTeamMember, 'id' | 'type' | 'teamId' | 'mute' | 'updateTime'>[];
        /**
         * 群的基础信息
         */
        team: NIMSuperTeam;
    }) => void;
    /** ========================== superTeam end ================================= */
    /** ========================== team start ================================= */
    /**
     * 初始化时同步群列表的回调。teams的属性 invalid 包含退出的群
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%A4%B4%E5%83%8F%E4%B8%8E%E5%90%8D%E7%A7%B0.js" target="_blank">会话头像与名称</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/team/%E7%BE%A4%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86.js" target="_blank">群成员管理</a></li>
     * </ul>
     */
    onteams?: (datas: NIMTeam[]) => void;
    /**
     * 多端登录时接收“创建群通知”的回调。
     *
     * @deprecated 请使用 {@link NIMGetInstanceOptions.onCreateTeam | onCreateTeam} 替代该回调
     */
    onsynccreateteam?: (data: NIMTeam) => void;
    /**
     * 在线或多端登录时接收“创建群通知”的回调。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.createTeam}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/team/%E7%BE%A4%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86.js" target="_blank">群成员管理</a></li>
     * </ul>
     */
    onCreateTeam?: (data: NIMTeam) => void;
    /**
     * 群资料更新时，或者更新群全体禁言状态时，群内在线成员都会收到该回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.updateTeam}</li>
     * <li>{@link TeamInterface.muteTeamAll}</li>
     * <li>{@link TeamInterface.updateInfoInTeam}</li>
     * <li>{@link TeamInterface.updateNickInTeam}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%A4%B4%E5%83%8F%E4%B8%8E%E5%90%8D%E7%A7%B0.js" target="_blank">会话头像与名称</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/team/%E7%BE%A4%E9%9D%99%E9%9F%B3.js" target="_blank">群静音</a></li>
     * </ul>
     */
    onUpdateTeam?: (data: NIMOnUpdateTeamResult1 | NIMOnUpdateTeamResult2 | NIMOnUpdateTeamResult3) => void;
    /**
     * 群解散时，群内所有成员收到 onDismissTeam 的回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.dismissTeam}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/team/%E7%BE%A4%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86.js" target="_blank">群成员管理</a></li>
     * </ul>
     */
    onDismissTeam?: (data: {
        teamId: string;
    }) => void;
    /**
     * 群主变更时，所有在线群成员都会收到此回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.transferTeam}</li>
     * </ul>
     */
    onTransferTeam?: (data: {
        /**
         * 转让者的信息
         */
        from: {
            /**
             * 群成员 ID (群 ID + account)
             */
            id: string;
            /**
             * 群成员类型
             *
             * <ul>
             * <li>'normal' (普通成员)</li>
             * <li>'owner' (群主)</li>
             * <li>'manager' (管理员)</li>
             * </ul>
             */
            type: 'normal' | 'owner' | 'manager';
            /**
             * 更新时间
             */
            updateTime: number;
        };
        /**
         * 被转让的目标用户的信息
         */
        to: {
            /**
             * 群成员 ID (群 ID + account)
             */
            id: string;
            /**
             * 群成员类型
             *
             * <ul>
             * <li>'normal' (普通成员)</li>
             * <li>'owner' (群主)</li>
             * <li>'manager' (管理员)</li>
             * </ul>
             */
            type: 'normal' | 'owner' | 'manager';
            /**
             * 更新时间
             */
            updateTime: number;
        };
        team: NIMTeam;
    }) => void;
    /**
     * 在线或多端同步时接收“群成员的信息变更”的回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.updateInfoInTeam}</li>
     * <li>{@link TeamInterface.updateNickInTeam}</li>
     * </ul>
     */
    onupdateteammember?: (data: Pick<NIMTeamMember, 'account' | 'custom' | 'id' | 'muteNotiType' | 'muteTeam' | 'nickInTeam' | 'teamId' | 'updateTime'>) => void;
    /**
     * (初始化同步, 在线, 多端同步)收到了当前账户，在各个群内的信息设置。比如当前用户是否为群主、管理员、是否设置了免打扰等等。
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/session/%E4%BC%9A%E8%AF%9D%E5%85%8D%E6%89%93%E6%89%B0.js" target="_blank">会话免打扰</a></li>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/team/%E6%88%91%E5%9C%A8%E7%BE%A4%E5%86%85%E4%BF%A1%E6%81%AF.js" target="_blank">我在群内信息</a></li>
     * </ul>
     */
    onMyTeamMembers?: (data: NIMTeamMember[]) => void;
    /**
     * 有成员进入群组时，包括该成员在内所有在线的客户端，触发该回调函数。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.createTeam} 创建群时，如果包含除了当前用户外的其它成员，会触发此回调</li>
     * <li>{@link TeamInterface.addTeamMembers} 拉人入群，或者邀请用户入群</li>
     * <li>{@link TeamInterface.acceptTeamInvite} 接受入群邀请</li>
     * <li>{@link TeamInterface.applyTeam} 申请入群</li>
     * <li>{@link TeamInterface.passTeamApply} 接受入群申请</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/team/%E7%BE%A4%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86.js" target="_blank">群成员管理</a></li>
     * </ul>
     *
     */
    onAddTeamMembers?: (data: {
        /**
         * 被添加的用户的账号
         */
        account: string[];
        /**
         * 被添加的用户的群成员信息
         */
        members: NIMTeamMember[];
        /**
         * 群的信息
         */
        team: NIMTeam;
    }) => void;
    /**
     * 有成员离开群组时，包括该成员在内所有在线的客户端，触发该回调函数。
     *
     * @notice 开发者需要判定 data 里 account 是否包含当前 IM 账号（accid）, 来处理当前 IM 账号被踢出群的情况。
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.leaveTeam} 主动退群</li>
     * <li>{@link TeamInterface.removeTeamMembers} 管理员移除成员</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/team/%E7%BE%A4%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86.js" target="_blank">群成员管理</a></li>
     * </ul>
     */
    onRemoveTeamMembers?: (data: {
        /**
         * 被添加的用户的 IM 账号（accid）
         */
        account: string[];
        /**
         * 群 ID
         */
        teamId: string;
        /**
         * 群的信息。
         *
         * 注: 已知主动离开群的场景触发的 onRemoveSuperTeamMembers 是不存在 team 信息的。
         */
        team?: NIMTeam;
    }) => void;
    /**
     * 群管理成员变更时，在线群成员会收到该回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.addTeamManagers}</li>
     * <li>{@link TeamInterface.removeTeamManagers}</li>
     * </ul>
     */
    onUpdateTeamManagers?: (data: {
        /**
         * 被添加的用户的账号
         */
        account: string[];
        /**
         * 是否为管理员.
         *
         * 若为 false 代表被移出管理员列表.
         */
        isManager: boolean;
        /**
         * 被添加的用户的群成员基础信息
         */
        members: {
            /**
             * 群成员 ID (群 ID + account)
             */
            id: string;
            /**
             * 成员 account
             */
            account: string;
            /**
             * 群成员类型
             *
             * <ul>
             * <li>'normal' (普通成员)</li>
             * <li>'owner' (群主)</li>
             * <li>'manager' (管理员)</li>
             * </ul>
             */
            type: 'normal' | 'owner' | 'manager';
            /**
             * 更新时间
             */
            updateTime: number;
        }[];
        /**
         * 群的基础信息
         */
        team: {
            /**
             * 群Id
             */
            teamId: string;
            /**
             * 群成员最后更新时间戳
             */
            memberUpdateTime: number;
        };
    }) => void;
    /**
     * 对指定成员禁言或者解除禁言后，群内所有在线成员收到该回调
     *
     * <h4>关联函数</h4>
     * <ul>
     * <li>{@link TeamInterface.updateMuteStateInTeam}</li>
     * </ul>
     *
     * <h4>示例场景</h4>
     * <ul>
     * <li><a href="https://github.com/netease-im/im-code-example-web/blob/master/im1/team/%E7%BE%A4%E9%9D%99%E9%9F%B3.js" target="_blank">群静音</a></li>
     * </ul>
     */
    onUpdateTeamMembersMute?: (data: {
        /**
         * 被添加的用户的账号
         */
        account: string[];
        /**
         * 是否静音.
         *
         * 若为 false 代表被移出静音列表.
         */
        mute: boolean;
        /**
         * 被添加的用户的群成员基础信息
         */
        members: {
            /**
             * 群成员 ID (群 ID + account)
             */
            id: string;
            /**
             * 群ID
             */
            teamId: string;
            /**
             * 群成员类型
             *
             * <ul>
             * <li>'normal' (普通成员)</li>
             * <li>'owner' (群主)</li>
             * <li>'manager' (管理员)</li>
             * </ul>
             */
            type: 'normal' | 'owner' | 'manager';
            /**
             * 更新时间
             */
            updateTime: number;
            /**
             * (该成员)是否被禁言
             */
            mute?: boolean;
        };
        /**
         * 群的基础信息
         */
        team: NIMTeam;
    }) => void;
}
export declare enum NIMEnumClientType {
    Android = 1,
    iOS = 2,
    PC = 4,
    WindowsPhone = 8,
    Web = 16,
    Server = 32,
    Mac = 64
}
export declare type NIMClientType = keyof typeof NIMEnumClientType;
export interface NIMOnLoginPortsChangeResult {
    /**
     * 登录的设备类型
     */
    type: string;
    /**
     * 登录设备的操作系统
     */
    os: string;
    /**
     * 登录设备的 mac 地址
     */
    mac: string;
    /**
     * 登录设备 ID
     */
    deviceId: string;
    /**
     * 登录的 IM 帐号（accid）
     */
    account: string;
    /**
     * 登录设备的连接号
     */
    connectionId: number;
    /**
     * 登录的服务器 IP
     */
    ip: string;
    /**
     * 登录时间
     */
    time: number;
    /**
     * 是否在线
     */
    online: boolean;
}
export interface NIMOnDisconnectResultOffline {
    /**
     * 断开的错误码。
     *
     * manuallyDisconnect 主动断开
     * offlineListener 监听到网络变化断开
     * allAttemptsFailed 重连次数达到上限而断开
     */
    code: string;
    /**
     * 原因描述
     */
    message: string;
    /**
     * 出处提示
     */
    callFunc: string;
}
export interface NIMOnDisconnectResultKicked {
    /**
     * 状态码
     */
    code: 'kicked';
    /**
     * 原因简述
     *
     * samePlatformKick: 不允许同一个 IM 帐号在多个地方同时登录
     * serverKick: 被服务器踢了
     * otherPlatformKick: 被其它端踢了
     */
    reason: string;
    /**
     * 原因描述
     */
    message: string;
    /**
     * 扩展字段
     */
    custom: string;
    /**
     * 客户端类型
     */
    from: NIMClientType;
    /**
     * 自定义端测类型
     */
    customClientType: number;
}
export interface NIMOnDisconnectResultOther {
    /**
     * 状态码
     */
    code: number;
    /**
     * 原因描述
     */
    message: string;
}
